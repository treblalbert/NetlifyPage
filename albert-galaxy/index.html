<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Albert's Galaxy - Leave Your Mark!</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            position: absolute;
            top: 0px;
            left: 0px;
            right: 0px;
            bottom: 0px;
            padding: 0px;
            margin: 0px;
            overflow: hidden;
            display: flex;
            height: 100%;
            width: 100%;
            background-color: #000;
            color: white;
            font-family: 'Arial', sans-serif;
        }

        /* Black hole shader background */
        #blackhole-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            margin: auto auto;
        }

        /* Three.js star galaxy layer */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* Crystal Glass Panel Style */
        .liquid-crystal-panel {
            position: relative;
            background: inherit;
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 8px;
            padding: 20px;
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 
                0 8px 32px 0 rgba(31, 38, 135, 0.37),
                inset 0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        .liquid-crystal-panel::before {
            content: '';
            position: absolute;
            top: -50px;
            left: -50px;
            right: -50px;
            bottom: -50px;
            background: inherit;
            z-index: -1;
            filter: blur(20px);
        }

        .liquid-crystal-panel::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            pointer-events: none;
        }

        #star-counter {
            position: absolute;
            bottom: 20px;
            right: 20px;
        }

        #search-container {
            position: absolute;
            top: 20px;
            right: 20px;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            max-width: 250px;
        }

        #star-details {
            position: absolute;
            bottom: 20px;
            left: 20px;
            max-width: 250px;
            min-width: 200px;
        }

        /* Clean Input Styles */
        #search-input, #user-name {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 12px;
            color: white;
            width: 100%;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        #search-input:focus, #user-name:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.4);
            background: rgba(255, 255, 255, 0.15);
        }

        #search-input::placeholder, #user-name::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        #search-results {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .search-result {
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            margin: 3px 0;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .search-result:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        #star-info-content {
            margin-top: 10px;
            position: relative;
            z-index: 10;
        }

        #star-info-content p {
            margin: 8px 0;
            font-size: 14px;
        }

        .star-name {
            color: #ffffff;
            font-weight: bold;
            font-size: 16px;
        }

        .star-color-badge {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.3);
            margin-right: 8px;
            vertical-align: middle;
        }

        /* Enhanced Modal Styles */
        #welcome-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            pointer-events: auto;
        }

        .modal-content {
            background: inherit;
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 8px 32px 0 rgba(31, 38, 135, 0.37),
                inset 0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: -50px;
            left: -50px;
            right: -50px;
            bottom: -50px;
            background: inherit;
            z-index: -1;
            filter: blur(20px);
        }

        .modal-content::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            pointer-events: none;
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: #ffffff;
            position: relative;
            z-index: 10;
        }

        .modal-content input[type="color"] {
            width: 60px;
            height: 40px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: transparent;
            cursor: pointer;
            margin: 10px;
        }

        .modal-content button {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin-top: 20px;
            transition: all 0.3s ease;
            position: relative;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .modal-content button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.05);
        }

        #color-preview {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            margin: 15px auto;
        }

        .hidden {
            display: none !important;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 20px;
            font-weight: normal;
            z-index: 500;
            animation: pulse 2s ease-in-out infinite;
        }

        /* Mobile touch feedback */
        .mobile-hint {
            position: fixed;
            bottom: 50%;
            left: 50%;
            transform: translate(-50%, 50%);
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            text-align: center;
            z-index: 500;
            pointer-events: none;
            animation: fadeInOut 4s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 0.7;
            }
            50% {
                opacity: 1;
            }
        }

        /* Clean scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        /* ============== MOBILE RESPONSIVE STYLES ============== */
        @media (max-width: 768px) {
            .liquid-crystal-panel {
                padding: 15px;
                font-size: 14px;
            }

            #instructions {
                max-width: 200px;
                top: 10px;
                left: 10px;
            }

            #search-container {
                top: 10px;
                right: 10px;
                min-width: 200px;
            }

            #star-counter {
                bottom: 10px;
                right: 10px;
                font-size: 13px;
            }

            #star-details {
                bottom: 10px;
                left: 10px;
                max-width: 200px;
                font-size: 13px;
            }

            #search-input, #user-name {
                padding: 15px;
                font-size: 16px; /* Prevents zoom on iOS */
                -webkit-appearance: none;
                border-radius: 8px;
            }

            .search-result {
                padding: 12px 8px;
                margin: 5px 0;
                font-size: 14px;
                min-height: 44px; /* Apple touch target size */
                display: flex;
                align-items: center;
            }

            .modal-content {
                margin: 20px;
                padding: 25px;
                max-width: calc(100% - 40px);
            }

            .modal-content input {
                padding: 15px;
                font-size: 16px; /* Prevents zoom on iOS */
                -webkit-appearance: none;
            }

            .modal-content button {
                padding: 18px 30px;
                font-size: 18px;
                min-height: 44px; /* Apple touch target size */
            }

            #instructions h3 {
                font-size: 16px;
                margin-bottom: 10px;
            }

            #instructions p {
                font-size: 13px;
                line-height: 1.4;
                margin: 5px 0;
            }

            /* Touch-friendly star info */
            #star-info-content p {
                margin: 6px 0;
                font-size: 13px;
                line-height: 1.3;
            }

            .star-name {
                font-size: 15px;
            }
        }

        @media (max-width: 480px) {
            .liquid-crystal-panel {
                padding: 12px;
                font-size: 13px;
            }

            #instructions, #search-container, #star-counter, #star-details {
                position: absolute;
                width: calc(100% - 20px);
                left: 10px;
                right: 10px;
                max-width: none;
            }

            #instructions {
                top: 10px;
            }

            #search-container {
                top: auto;
                bottom: 200px;
            }

            #star-counter {
                bottom: 100px;
            }

            #star-details {
                bottom: 10px;
            }

            .modal-content {
                margin: 10px;
                padding: 20px;
                max-width: calc(100% - 20px);
            }
        }

        /* Prevent text selection during touch interactions */
        #canvas-container {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none;
        }

        /* Modal should block all background interaction */
        #welcome-modal {
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Modal content should allow normal interaction */
        .modal-content {
            touch-action: auto;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        /* Improve touch targets */
        button, input, .search-result {
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.1);
        }

        /* ============== UI TOGGLE BUTTON ============== */
        .ui-toggle-button {
            position: fixed;
            top: 20px;
            right: 50%;
            transform: translateX(50%);
            z-index: 1001;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50px;
            color: white;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
            min-height: 44px; /* Touch target */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ui-toggle-button:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateX(50%) scale(1.05);
        }

        /* UI Panels container for toggling */
        .ui-panels {
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .ui-panels.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        /* Mobile adjustments for toggle button */
        @media (max-width: 768px) {
            .ui-toggle-button {
                top: 10px;
                padding: 15px 25px;
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <!-- Black Hole Shader Scripts -->
    <script id="2d-fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif
        #define PI 3.14159265359
        uniform sampler2D u_image;
        varying vec2 v_texCoord;
        uniform vec2 u_resolution;
        uniform vec2 u_mouse;
        uniform float u_mass;
        uniform float u_time;
        uniform float u_clickedTime;
        vec2 rotate(vec2 mt, vec2 st, float angle){
        float cos = cos((angle + u_clickedTime) * PI);
        float sin = sin(angle * 0.0);
        float nx = (cos * (st.x - mt.x)) + (sin * (st.y - mt.y)) + mt.x;
        float ny = (cos * (st.y - mt.y)) - (sin * (st.x - mt.x)) + mt.y;
        return vec2(nx, ny);
        }
        void main() {
        vec2 st = gl_FragCoord.xy / u_resolution.xy;
        vec2 mt = vec2(u_mouse.x / u_resolution.x, 1.0 - (u_mouse.y / u_resolution.y));
        
        float dx = st.x - mt.x;
        float dy = st.y - mt.y;
        float dist = sqrt(dx * dx + dy * dy);
        float pull = u_mass / (dist * dist);
        vec3 color = vec3(0.0);
        vec2 r = rotate(mt,st,pull);
        vec4 imgcolor = texture2D(u_image, r);
        color = vec3(
        (imgcolor.x - (pull * 0.25)),
        (imgcolor.y - (pull * 0.25)),
        (imgcolor.z - (pull * 0.25))
        );
        gl_FragColor = vec4(color,1.);
        }
    </script>
    <script id="2d-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;
        void main() {
        gl_Position = vec4(a_position, 0, 1);
        v_texCoord = a_texCoord;
        }
    </script>

    <!-- Black hole background layer -->
    <canvas id="blackhole-canvas"></canvas>
    
    <div id="loading">üåü Loading galaxy...</div>
    
    <!-- Mobile touch hint -->
    <div id="mobile-hint" class="mobile-hint hidden">
        üëÜ Drag to rotate ‚Ä¢ ü§è Pinch to zoom ‚Ä¢ üëá Tap stars
    </div>
    
    <!-- Three.js star galaxy layer -->
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <!-- Always visible UI toggle button -->
        <button id="ui-toggle" class="ui-toggle-button" onclick="toggleUI()" title="Show/Hide Interface">
            <span id="ui-toggle-icon">üëÅÔ∏è</span>
        </button>

        <div class="ui-panels">
            <div id="instructions" class="liquid-crystal-panel">
                <h3>üåü Albert's Galaxy</h3>
                <p><strong>Controls:</strong></p>
                <p>‚Ä¢ Drag: Rotate view</p>
                <p>‚Ä¢ Scroll/Pinch: Zoom in/out</p>
                <p>‚Ä¢ Tap/Click stars to focus & follow</p>
                <p>‚Ä¢ Space: Return to center & stop following</p>
                <p>‚Ä¢ H/I: Toggle interface</p>
                <p><br><em>Welcome to the galaxy! Your star will orbit the central black hole and may develop its own planetary system, connecting to nearby stars in clusters.</em></p>
            </div>

            <div id="search-container" class="liquid-crystal-panel">
                <input type="text" id="search-input" placeholder="Search stars by name...">
                <div id="search-results"></div>
            </div>

            <div id="star-counter" class="liquid-crystal-panel">
                <h3>‚≠ê Galaxy Stats</h3>
                <p>Status: <span id="connection-status">üîÑ Connecting...</span></p>
                <p>Total Stars: <span id="star-count">0</span></p>
                <p>Star Clusters: <span id="cluster-count">0</span></p>
                <p>Planetary Systems: <span id="system-count">0</span></p>
                <p>Total Planets: <span id="planet-count">0</span></p>
                <p>Unique Visitors: <span id="visitor-count">0</span></p>
            </div>

            <div id="star-details" class="liquid-crystal-panel">
                <h3>üåü Star Details</h3>
                <div id="star-info-content">
                    <p><em>Click on a star or the black hole to see details and start following it with the camera</em></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Welcome Modal -->
    <div id="welcome-modal" class="hidden">
        <div class="modal-content">
            <h2>üåü Welcome to the Albert Galaxy!</h2>
            <p>Leave your mark in the cosmos by creating your own star. Your star will orbit the central black hole, may develop its own planetary system, and connect to nearby stars!</p>
            
            <input type="text" id="user-name" placeholder="Enter your name" maxlength="20">
            
            <div>
                <label for="star-color">Choose your star color:</label>
                <input type="color" id="star-color" value="#ffffff">
                <div id="color-preview" style="background-color: #ffffff;"></div>
            </div>
            
            <button id="create-star" onclick="createUserStar()">Create My Star ‚ú®</button>
        </div>
    </div>

    <script>
        // ============== BLACK HOLE SHADER CONFIGURATION ==============
        var bgUrl = 'background.jpg';
        var blackholeMass = 1500;
        var curblackholeMass = 0;
        var blackholeCanvas, blackholeGl;
        var shaderScript, shaderSource, vertexShader, fragmentShader, buffer;
        var locationOfTime, locationOfResolution, locationOfMouse, locationOfMass, locationOfclickedTime;
        var originY = window.innerHeight, originX = window.innerWidth;
        var blackholeMouse;
        var startTime = new Date().getTime();
        var currentTime = 0;

        // ============== SUPABASE CONFIGURATION ==============
        const SUPABASE_URL = 'https://kncwqtqmbyukguuargsg.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtuY3dxdHFtYnl1a2d1dWFyZ3NnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk3NDQ4MDUsImV4cCI6MjA2NTMyMDgwNX0.WvxeazNz2y-F57JE0fvT4XVXkEMZQ-R_sviYaSrRuNg';

        let supabaseClient = null;
        let isOnlineMode = false;

        try {
            if (typeof window.supabase !== 'undefined' && window.supabase.createClient) {
                const { createClient } = window.supabase;
                supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                isOnlineMode = true;
                console.log('üü¢ Online mode: Connected to Supabase');
            } else {
                throw new Error('Supabase library not found');
            }
        } catch (error) {
            console.log('üü° Offline mode: Supabase connection failed', error);
            isOnlineMode = false;
        }

        function updateConnectionStatus() {
            const statusElement = document.getElementById('connection-status');
            if (isOnlineMode) {
                statusElement.innerHTML = 'üü¢ Online (Database)';
                statusElement.style.color = '#90EE90';
            } else {
                statusElement.innerHTML = 'üü° Offline (Local)';
                statusElement.style.color = '#FFD700';
            }
        }

        // ============== DATA MANAGEMENT ==============
        let galaxyData = { stars: [], visitCount: 0 };
        let scene, camera, renderer, composer;
        let starMeshes = [];
        let starClusters = [];
        let clusterLines = [];
        let planetarySystems = [];
        let centralBlackHole = null;
        let followingTarget = null;
        let selectedStar = null;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraDistance = 50;
        let cameraRotation = { x: 0, y: 0 };
        let focusTarget = new THREE.Vector3(0, 0, 0);
        const rotationSpeed = 0.005;
        let currentUser = null;

        // ============== UI TOGGLE FUNCTIONALITY ==============
        let isUIVisible = true;

        function toggleUI() {
            const uiPanels = document.querySelector('.ui-panels');
            const toggleIcon = document.getElementById('ui-toggle-icon');
            
            isUIVisible = !isUIVisible;
            
            if (isUIVisible) {
                uiPanels.classList.remove('hidden');
                toggleIcon.textContent = 'üëÅÔ∏è';
                document.getElementById('ui-toggle').title = 'Hide Interface';
            } else {
                uiPanels.classList.add('hidden');
                toggleIcon.textContent = 'üëÅÔ∏è‚Äçüó®Ô∏è';
                document.getElementById('ui-toggle').title = 'Show Interface';
            }
        }

        // ============== MOBILE DETECTION AND HINTS ==============
        function isMobileDevice() {
            return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1) || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function showMobileHint() {
            if (isMobileDevice()) {
                const mobileHint = document.getElementById('mobile-hint');
                mobileHint.classList.remove('hidden');
                setTimeout(() => {
                    mobileHint.classList.add('hidden');
                }, 4000);
            }
        }

        // ============== BLACK HOLE SHADER FUNCTIONS ==============
        function initBlackHole(image) {
            blackholeCanvas = document.getElementById('blackhole-canvas');
            blackholeGl = blackholeCanvas.getContext('webgl') || blackholeCanvas.getContext('experimental-webgl');
            
            blackholeCanvas.width = window.innerWidth;
            blackholeCanvas.height = window.innerHeight;
            blackholeCanvas.style.width = window.innerWidth + 'px';
            blackholeCanvas.style.height = window.innerHeight + 'px';
            
            blackholeMouse = {x: window.innerWidth/2, y: window.innerHeight/2, moved: false};
            
            $(document).mousemove(function(e) {
                blackholeMouse.x = e.pageX;
                blackholeMouse.y = e.pageY;
                blackholeMouse.moved = true;
            });

            blackholeGl.viewport(0, 0, blackholeCanvas.width, blackholeCanvas.height);
            
            buffer = blackholeGl.createBuffer();
            blackholeGl.bindBuffer(blackholeGl.ARRAY_BUFFER, buffer);
            blackholeGl.bufferData(
                blackholeGl.ARRAY_BUFFER,
                new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]),
                blackholeGl.STATIC_DRAW
            );

            shaderScript = document.getElementById("2d-vertex-shader");
            shaderSource = shaderScript.text;
            vertexShader = blackholeGl.createShader(blackholeGl.VERTEX_SHADER);
            blackholeGl.shaderSource(vertexShader, shaderSource);
            blackholeGl.compileShader(vertexShader);

            shaderScript = document.getElementById("2d-fragment-shader");
            shaderSource = shaderScript.text;
            fragmentShader = blackholeGl.createShader(blackholeGl.FRAGMENT_SHADER);
            blackholeGl.shaderSource(fragmentShader, shaderSource);
            blackholeGl.compileShader(fragmentShader);

            program = blackholeGl.createProgram();
            blackholeGl.attachShader(program, vertexShader);
            blackholeGl.attachShader(program, fragmentShader);
            blackholeGl.linkProgram(program);
            blackholeGl.useProgram(program);

            locationOfResolution = blackholeGl.getUniformLocation(program, "u_resolution");
            locationOfMouse = blackholeGl.getUniformLocation(program, "u_mouse");
            locationOfMass = blackholeGl.getUniformLocation(program, "u_mass");
            locationOfTime = blackholeGl.getUniformLocation(program, "u_time");
            locationOfclickedTime = blackholeGl.getUniformLocation(program, "u_clickedTime");

            blackholeGl.uniform2f(locationOfResolution, blackholeCanvas.width, blackholeCanvas.height);
            blackholeGl.uniform2f(locationOfMouse, blackholeMouse.x, blackholeMouse.y);
            blackholeGl.uniform1f(locationOfMass, curblackholeMass*0.00001);
            blackholeGl.uniform1f(locationOfTime, currentTime);
            blackholeGl.uniform1f(locationOfclickedTime, 0);

            var texCoordLocation = blackholeGl.getAttribLocation(program, "a_texCoord");
            var texCoordBuffer = blackholeGl.createBuffer();
            blackholeGl.bindBuffer(blackholeGl.ARRAY_BUFFER, texCoordBuffer);
            blackholeGl.bufferData(blackholeGl.ARRAY_BUFFER, new Float32Array([
                -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]),
                blackholeGl.STATIC_DRAW);
            blackholeGl.enableVertexAttribArray(texCoordLocation);
            blackholeGl.vertexAttribPointer(texCoordLocation, 2, blackholeGl.FLOAT, false, 0, 0);

            var texture = blackholeGl.createTexture();
            blackholeGl.bindTexture(blackholeGl.TEXTURE_2D, texture);
            blackholeGl.texParameteri(blackholeGl.TEXTURE_2D, blackholeGl.TEXTURE_WRAP_S, blackholeGl.CLAMP_TO_EDGE);
            blackholeGl.texParameteri(blackholeGl.TEXTURE_2D, blackholeGl.TEXTURE_WRAP_T, blackholeGl.CLAMP_TO_EDGE);
            blackholeGl.texParameteri(blackholeGl.TEXTURE_2D, blackholeGl.TEXTURE_MIN_FILTER, blackholeGl.NEAREST);
            blackholeGl.texParameteri(blackholeGl.TEXTURE_2D, blackholeGl.TEXTURE_MAG_FILTER, blackholeGl.NEAREST);
            blackholeGl.texImage2D(blackholeGl.TEXTURE_2D, 0, blackholeGl.RGBA, blackholeGl.RGBA, blackholeGl.UNSIGNED_BYTE, image);

            renderBlackHole();
        }

        function renderBlackHole() {
            var now = new Date().getTime();
            currentTime = (now - startTime) / 1000;
            
            if(curblackholeMass < blackholeMass - 50){
                curblackholeMass += (blackholeMass-curblackholeMass) * 0.03;
            }
            
            if(blackholeMouse.moved == false){
                blackholeMouse.x = (window.innerWidth/2) + Math.sin(currentTime * 0.6) * (window.innerWidth * 0.35);
                blackholeMouse.y = (window.innerHeight/2) + Math.sin(currentTime * 0.7) * (window.innerHeight * 0.25);
            }

            blackholeGl.uniform1f(locationOfMass, curblackholeMass*0.00001);
            blackholeGl.uniform2f(locationOfMouse, blackholeMouse.x, blackholeMouse.y);
            blackholeGl.uniform1f(locationOfTime, currentTime);
            blackholeGl.uniform1f(locationOfclickedTime, 0);

            window.requestAnimationFrame(renderBlackHole, blackholeCanvas);
            
            positionLocation = blackholeGl.getAttribLocation(program, "a_position");
            blackholeGl.enableVertexAttribArray(positionLocation);
            blackholeGl.vertexAttribPointer(positionLocation, 2, blackholeGl.FLOAT, false, 0, 0);
            blackholeGl.drawArrays(blackholeGl.TRIANGLES, 0, 6);
        }

        // ============== DATABASE FUNCTIONS ==============
        async function checkExistingUser() {
            const fingerprint = await generateUserFingerprint();
            
            if (isOnlineMode) {
                try {
                    const { data, error } = await supabaseClient
                        .from('galaxy_users')
                        .select('*')
                        .eq('fingerprint', fingerprint)
                        .single();
                    
                    if (data && !error) {
                        currentUser = data;
                        return true;
                    }
                } catch (error) {
                    console.log('User not found in database');
                }
            } else {
                const existingUser = JSON.parse(localStorage.getItem('galaxy_user_' + fingerprint) || 'null');
                if (existingUser) {
                    currentUser = existingUser;
                    return true;
                }
            }
            
            return false;
        }

        async function generateUserFingerprint() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('Browser fingerprint', 2, 2);
            
            const fingerprint = [
                navigator.userAgent,
                navigator.language,
                screen.width + 'x' + screen.height,
                new Date().getTimezoneOffset(),
                canvas.toDataURL()
            ].join('|');
            
            let hash = 0;
            for (let i = 0; i < fingerprint.length; i++) {
                const char = fingerprint.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            
            return Math.abs(hash).toString();
        }

        async function saveUser(userData) {
            const fingerprint = await generateUserFingerprint();
            const userRecord = {
                fingerprint: fingerprint,
                name: userData.name,
                created_at: new Date().toISOString()
            };

            if (isOnlineMode) {
                try {
                    const { data, error } = await supabaseClient
                        .from('galaxy_users')
                        .insert([userRecord])
                        .select()
                        .single();
                    
                    if (!error) {
                        currentUser = data;
                        return true;
                    }
                } catch (error) {
                    console.error('Error saving user:', error);
                }
            } else {
                localStorage.setItem('galaxy_user_' + fingerprint, JSON.stringify(userRecord));
                currentUser = userRecord;
                return true;
            }
            
            return false;
        }

        async function loadAllStars() {
            if (isOnlineMode) {
                try {
                    console.log('üîÑ Loading stars from database...');
                    const { data, error } = await supabaseClient
                        .from('galaxy_stars')
                        .select('*')
                        .order('created_at', { ascending: true });
                    
                    if (error) {
                        console.error('‚ùå Database error:', error);
                        isOnlineMode = false;
                        updateConnectionStatus();
                        return getDefaultStars();
                    }
                    
                    if (data) {
                        console.log(`‚úÖ Loaded ${data.length} stars from database`);
                        return data.map((star, index) => ({
                            id: star.id,
                            name: star.name,
                            color: star.color,
                            position: star.position,
                            planets: star.planets || generatePlanetData(star.name),
                            orbital: star.orbital || generateOrbitalData(star.name, index),
                            timestamp: star.created_at
                        }));
                    }
                } catch (error) {
                    console.error('‚ùå Error loading stars:', error);
                    isOnlineMode = false;
                    updateConnectionStatus();
                }
            } else {
                const starsData = localStorage.getItem('galaxy_stars');
                if (starsData) {
                    const stars = JSON.parse(starsData);
                    return stars.map((star, index) => ({
                        ...star,
                        planets: star.planets || generatePlanetData(star.name),
                        orbital: star.orbital || generateOrbitalData(star.name, index)
                    }));
                }
            }
            
            return getDefaultStars();
        }

        function getDefaultStars() {
            return [{ 
                name: "PointZero", 
                color: "#ff6b6b", 
                position: { x: 0, y: 0, z: 0 }, 
                planets: generatePlanetData("PointZero"),
                orbital: generateOrbitalData("PointZero", 0),
                timestamp: new Date().toISOString() 
            }];
        }

        async function saveStar(starData) {
            if (isOnlineMode) {
                try {
                    console.log('üíæ Saving star to database:', starData.name);
                    const { data, error } = await supabaseClient
                        .from('galaxy_stars')
                        .insert([{
                            name: starData.name,
                            color: starData.color,
                            position: starData.position,
                            planets: starData.planets,
                            orbital: starData.orbital,
                            created_at: starData.timestamp
                        }])
                        .select()
                        .single();
                    
                    if (error) {
                        console.error('‚ùå Error saving star:', error);
                        isOnlineMode = false;
                        updateConnectionStatus();
                        return await saveStar(starData);
                    }
                    
                    if (data) {
                        console.log('‚úÖ Star saved successfully!');
                        return { ...starData, id: data.id };
                    }
                } catch (error) {
                    console.error('‚ùå Database connection error:', error);
                    isOnlineMode = false;
                    updateConnectionStatus();
                    return await saveStar(starData);
                }
            } else {
                const existingStars = JSON.parse(localStorage.getItem('galaxy_stars') || '[]');
                const newStar = { ...starData, id: Date.now() };
                existingStars.push(newStar);
                localStorage.setItem('galaxy_stars', JSON.stringify(existingStars));
                console.log('üíæ Star saved to localStorage (offline mode)');
                return newStar;
            }
            
            return null;
        }

        // ============== PLANETARY SYSTEM FUNCTIONS ==============
        function generatePlanetData(starName) {
            let seed = 0;
            for (let i = 0; i < starName.length; i++) {
                seed += starName.charCodeAt(i);
            }
            
            function seededRandom() {
                seed = (seed * 9301 + 49297) % 233280;
                return seed / 233280;
            }
            
            const planetCount = Math.floor(seededRandom() * 7) + 1;
            const planets = [];
            
            const planetColors = [
                '#8B4513', '#CD853F', '#DEB887', '#F4A460',
                '#4169E1', '#6495ED', '#87CEEB', '#B0C4DE',
                '#228B22', '#32CD32', '#90EE90', '#98FB98',
                '#DC143C', '#FF6347', '#FF7F50', '#FFA07A',
                '#9370DB', '#BA55D3', '#DDA0DD', '#E6E6FA'
            ];
            
            for (let p = 0; p < planetCount; p++) {
                const orbitRadius = 2 + (p * 1.5) + seededRandom() * 0.8;
                const planetSize = 0.1 + seededRandom() * 0.15;
                const orbitalSpeed = (0.02 + seededRandom() * 0.03) / (p + 1);
                const startAngle = seededRandom() * Math.PI * 2;
                const planetColor = planetColors[Math.floor(seededRandom() * planetColors.length)];
                
                planets.push({
                    name: `${starName}-${p + 1}`,
                    orbitRadius: orbitRadius,
                    size: planetSize,
                    orbitalSpeed: orbitalSpeed,
                    startAngle: startAngle,
                    color: planetColor
                });
            }
            
            return planets;
        }

        // ============== CENTRAL BLACK HOLE & ORBITAL MECHANICS ==============
        function generateOrbitalData(starName, starIndex) {
            let seed = 0;
            for (let i = 0; i < starName.length; i++) {
                seed += starName.charCodeAt(i);
            }
            seed += starIndex * 1000;
            
            function seededRandom() {
                seed = (seed * 9301 + 49297) % 233280;
                return seed / 233280;
            }
            
            if (starName === "PointZero") {
                return {
                    radius: 15,
                    speed: 0.001,
                    currentAngle: 0,
                    originalPosition: { x: 0, y: 0, z: 0 }
                };
            }
            
            const orbitRadius = 20 + seededRandom() * 60;
            const orbitalSpeed = (0.0005 + seededRandom() * 0.002);
            const startAngle = seededRandom() * Math.PI * 2;
            
            const x = orbitRadius * Math.cos(startAngle);
            const z = orbitRadius * Math.sin(startAngle);
            const y = (seededRandom() - 0.5) * 20;
            
            return {
                radius: orbitRadius,
                speed: orbitalSpeed,
                currentAngle: startAngle,
                originalPosition: { x, y, z }
            };
        }

        function createCentralBlackHole() {
            // Create the main black hole
            const blackHoleGeometry = new THREE.SphereGeometry(2.5, 32, 32);
            const blackHoleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x0a0a0a,
                transparent: true,
                opacity: 0.95
            });
            
            centralBlackHole = new THREE.Mesh(blackHoleGeometry, blackHoleMaterial);
            centralBlackHole.position.set(0, 0, 0);
            
            // Add special properties to make it selectable like a star
            centralBlackHole.userData = {
                name: "Lil Bingus",
                type: "black-hole",
                color: "#000000",
                position: { x: 0, y: 0, z: 0 },
                timestamp: "Beginning of Time"
            };
            
            // Create multiple glow layers
            const glowLayers = [];
            const glowSizes = [4, 6, 8, 12];
            const glowColors = [0x4400aa, 0x6600cc, 0x8800ee, 0xaa00ff];
            const glowOpacities = [0.15, 0.1, 0.06, 0.03];
            
            glowSizes.forEach((size, index) => {
                const glowGeometry = new THREE.SphereGeometry(size, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: glowColors[index],
                    transparent: true,
                    opacity: glowOpacities[index],
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.set(0, 0, 0);
                scene.add(glow);
                glowLayers.push(glow);
            });
            
            // Create accretion disk
            const diskGeometry = new THREE.RingGeometry(3, 15, 64);
            const diskMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4400,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            const accretionDisk = new THREE.Mesh(diskGeometry, diskMaterial);
            accretionDisk.rotation.x = Math.PI / 2 + 0.1;
            accretionDisk.position.set(0, 0, 0);
            scene.add(accretionDisk);
            
            // Create inner hot disk
            const innerDiskGeometry = new THREE.RingGeometry(3, 8, 32);
            const innerDiskMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            const innerDisk = new THREE.Mesh(innerDiskGeometry, innerDiskMaterial);
            innerDisk.rotation.x = Math.PI / 2 + 0.1;
            innerDisk.position.set(0, 0, 0);
            scene.add(innerDisk);
            
            // Create particle jets
            const jetParticles = [];
            for (let i = 0; i < 2; i++) {
                const jetGeometry = new THREE.BufferGeometry();
                const jetCount = 100;
                const positions = new Float32Array(jetCount * 3);
                
                for (let j = 0; j < jetCount; j++) {
                    const t = j / jetCount;
                    const y = (i === 0 ? 1 : -1) * (5 + t * 30);
                    const spread = 0.2 + t * 0.5;
                    positions[j * 3] = (Math.random() - 0.5) * spread;
                    positions[j * 3 + 1] = y;
                    positions[j * 3 + 2] = (Math.random() - 0.5) * spread;
                }
                
                jetGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const jetMaterial = new THREE.PointsMaterial({
                    color: 0x00aaff,
                    size: 0.3,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                
                const jet = new THREE.Points(jetGeometry, jetMaterial);
                scene.add(jet);
                jetParticles.push(jet);
            }
            
            scene.add(centralBlackHole);
            
            // Store all the components for animation
            centralBlackHole.userData.glowLayers = glowLayers;
            centralBlackHole.userData.accretionDisk = accretionDisk;
            centralBlackHole.userData.innerDisk = innerDisk;
            centralBlackHole.userData.jetParticles = jetParticles;
            
            console.log('üï≥Ô∏è Created enhanced central black hole "Lil Bingus" with accretion disk');
        }

        function updateStarOrbitalPositions() {
            starMeshes.forEach((starObj, index) => {
                const orbital = starObj.data.orbital;
                if (!orbital) return;
                
                orbital.currentAngle += orbital.speed;
                
                const x = orbital.radius * Math.cos(orbital.currentAngle);
                const z = orbital.radius * Math.sin(orbital.currentAngle);
                const y = orbital.originalPosition.y;
                
                starObj.group.position.set(x, y, z);
                starObj.data.position = { x, y, z };
                
                const system = planetarySystems.find(sys => sys.starName === starObj.data.name);
                if (system) {
                    system.planets.forEach(planetData => {
                        planetData.starPosition = { x, y, z };
                    });
                    
                    system.orbitLines.forEach(orbitLine => {
                        orbitLine.position.set(x, y, z);
                    });
                }
            });
            
            updateClusterLines();
        }

        function updateClusterLines() {
            clusterLines.forEach(line => {
                const star1Index = line.userData.star1;
                const star2Index = line.userData.star2;
                
                if (star1Index < starMeshes.length && star2Index < starMeshes.length) {
                    const star1Pos = starMeshes[star1Index].data.position;
                    const star2Pos = starMeshes[star2Index].data.position;
                    
                    const positions = new Float32Array([
                        star1Pos.x, star1Pos.y, star1Pos.z,
                        star2Pos.x, star2Pos.y, star2Pos.z
                    ]);
                    line.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                }
            });
        }

        function createPlanetarySystemFromData(starObj, starIndex) {
            const starName = starObj.data.name;
            const starPosition = starObj.data.position;
            const planetData = starObj.data.planets;
            
            if (!planetData || planetData.length === 0) {
                console.warn(`No planet data for star ${starName}`);
                return false;
            }
            
            const systemData = {
                starIndex: starIndex,
                starName: starName,
                planets: [],
                orbitLines: [],
                moons: [],
                rings: []
            };

            planetData.forEach((planetInfo, p) => {
                // Create main planet with enhanced materials
                const planetGeometry = new THREE.SphereGeometry(planetInfo.size, 16, 16);
                
                // Enhanced planet material with subtle glow
                const planetMaterial = new THREE.MeshBasicMaterial({ 
                    color: planetInfo.color
                });
                const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
                
                // Add planet atmosphere
                const atmosphereGeometry = new THREE.SphereGeometry(planetInfo.size * 1.1, 12, 12);
                const atmosphereMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(planetInfo.color).multiplyScalar(0.7),
                    transparent: true,
                    opacity: 0.2,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });
                const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                
                const planetGroup = new THREE.Group();
                planetGroup.add(planetMesh);
                planetGroup.add(atmosphere);
                
                planetGroup.position.set(
                    starPosition.x + planetInfo.orbitRadius * Math.cos(planetInfo.startAngle),
                    starPosition.y,
                    starPosition.z + planetInfo.orbitRadius * Math.sin(planetInfo.startAngle)
                );

                scene.add(planetGroup);

                // Create planetary rings for larger planets
                if (planetInfo.size > 0.15 && Math.random() > 0.7) {
                    const ringInnerRadius = planetInfo.size * 1.5;
                    const ringOuterRadius = planetInfo.size * 2.5;
                    const ringGeometry = new THREE.RingGeometry(ringInnerRadius, ringOuterRadius, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: new THREE.Color(planetInfo.color).multiplyScalar(0.8),
                        transparent: true,
                        opacity: 0.6,
                        side: THREE.DoubleSide
                    });
                    const rings = new THREE.Mesh(ringGeometry, ringMaterial);
                    rings.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.3;
                    planetGroup.add(rings);
                    systemData.rings.push(rings);
                }
                
                // Create moons for planets
                const moonCount = planetInfo.size > 0.2 ? Math.floor(Math.random() * 3) + 1 : 0;
                const planetMoons = [];
                
                for (let m = 0; m < moonCount; m++) {
                    const moonSize = planetInfo.size * (0.1 + Math.random() * 0.2);
                    const moonOrbitRadius = planetInfo.size * (2 + m * 0.8);
                    const moonGeometry = new THREE.SphereGeometry(moonSize, 8, 8);
                    const moonColor = new THREE.Color(planetInfo.color).multiplyScalar(0.6 + Math.random() * 0.4);
                    const moonMaterial = new THREE.MeshBasicMaterial({ color: moonColor });
                    const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
                    
                    const moonAngle = Math.random() * Math.PI * 2;
                    moonMesh.position.set(
                        moonOrbitRadius * Math.cos(moonAngle),
                        0,
                        moonOrbitRadius * Math.sin(moonAngle)
                    );
                    
                    planetGroup.add(moonMesh);
                    
                    planetMoons.push({
                        mesh: moonMesh,
                        orbitRadius: moonOrbitRadius,
                        currentAngle: moonAngle,
                        orbitalSpeed: 0.1 + Math.random() * 0.1
                    });
                }

                // Enhanced orbit visualization
                const orbitGeometry = new THREE.RingGeometry(planetInfo.orbitRadius - 0.02, planetInfo.orbitRadius + 0.02, 64);
                const orbitMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(planetInfo.color).multiplyScalar(0.8),
                    transparent: true,
                    opacity: 0.25,
                    side: THREE.DoubleSide
                });
                const orbitLine = new THREE.Mesh(orbitGeometry, orbitMaterial);
                
                orbitLine.position.set(starPosition.x, starPosition.y, starPosition.z);
                orbitLine.rotation.x = Math.PI / 2;
                
                scene.add(orbitLine);

                const planetRuntimeData = {
                    name: planetInfo.name,
                    mesh: planetMesh,
                    group: planetGroup,
                    atmosphere: atmosphere,
                    moons: planetMoons,
                    orbitRadius: planetInfo.orbitRadius,
                    orbitalSpeed: planetInfo.orbitalSpeed,
                    currentAngle: planetInfo.startAngle,
                    color: planetInfo.color,
                    size: planetInfo.size,
                    starPosition: starPosition
                };

                systemData.planets.push(planetRuntimeData);
                systemData.orbitLines.push(orbitLine);
                systemData.moons = systemData.moons.concat(planetMoons);
            });

            planetarySystems.push(systemData);
            return true;
        }

        function createAllPlanetarySystems() {
            planetarySystems = [];
            let totalSystemsCreated = 0;
            let totalPlanetsCreated = 0;

            starMeshes.forEach((starObj, starIndex) => {
                if (createPlanetarySystemFromData(starObj, starIndex)) {
                    totalSystemsCreated++;
                    totalPlanetsCreated += planetarySystems[planetarySystems.length - 1].planets.length;
                }
            });

            console.log(`ü™ê Created ${totalSystemsCreated} planetary systems with ${totalPlanetsCreated} total planets`);
        }

        function animatePlanets() {
            planetarySystems.forEach(system => {
                system.planets.forEach(planetData => {
                    planetData.currentAngle += planetData.orbitalSpeed;
                    
                    const x = planetData.starPosition.x + planetData.orbitRadius * Math.cos(planetData.currentAngle);
                    const z = planetData.starPosition.z + planetData.orbitRadius * Math.sin(planetData.currentAngle);
                    
                    planetData.group.position.set(x, planetData.starPosition.y, z);
                    
                    // Rotate planet on its axis
                    planetData.mesh.rotation.y += 0.05;
                    
                    // Animate atmosphere
                    if (planetData.atmosphere) {
                        planetData.atmosphere.rotation.y += 0.02;
                        planetData.atmosphere.rotation.x += 0.01;
                    }
                    
                    // Animate moons
                    planetData.moons.forEach(moon => {
                        moon.currentAngle += moon.orbitalSpeed;
                        moon.mesh.position.set(
                            moon.orbitRadius * Math.cos(moon.currentAngle),
                            0,
                            moon.orbitRadius * Math.sin(moon.currentAngle)
                        );
                        moon.mesh.rotation.y += 0.1;
                    });
                });
                
                // Animate planetary rings
                system.rings.forEach(ring => {
                    ring.rotation.z += 0.01;
                });
            });
        }

        function getStarPlanetaryInfo(starData) {
            const system = planetarySystems.find(sys => sys.starName === starData.name);
            if (system) {
                return {
                    planetCount: system.planets.length,
                    planetNames: system.planets.map(p => p.name),
                    hasSystem: true
                };
            }
            return { hasSystem: false };
        }

        // ============== STAR CLUSTER FUNCTIONS ==============
        function calculateDistance(pos1, pos2) {
            const dx = pos1.x - pos2.x;
            const dy = pos1.y - pos2.y;
            const dz = pos1.z - pos2.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        function findStarClusters() {
            const MAX_CLUSTER_DISTANCE = 25;
            const MIN_CLUSTER_SIZE = 3;
            const MAX_CLUSTER_SIZE = 6;
            const clusters = [];
            const usedStars = new Set();

            for (let i = 0; i < starMeshes.length; i++) {
                if (usedStars.has(i)) continue;

                const currentStar = starMeshes[i];
                const cluster = [i];
                usedStars.add(i);

                for (let j = 0; j < starMeshes.length; j++) {
                    if (i === j || usedStars.has(j) || cluster.length >= MAX_CLUSTER_SIZE) continue;

                    const distance = calculateDistance(
                        currentStar.data.position,
                        starMeshes[j].data.position
                    );

                    if (distance <= MAX_CLUSTER_DISTANCE) {
                        cluster.push(j);
                        usedStars.add(j);
                    }
                }

                if (cluster.length >= MIN_CLUSTER_SIZE) {
                    clusters.push(cluster);
                }
            }

            return clusters;
        }

        function createClusterLines() {
            clusterLines.forEach(line => scene.remove(line));
            clusterLines = [];

            starClusters = findStarClusters();
            console.log(`üåå Created ${starClusters.length} star clusters`);

            starClusters.forEach((cluster, clusterIndex) => {
                for (let i = 0; i < cluster.length; i++) {
                    const currentStarIndex = cluster[i];
                    const currentStar = starMeshes[currentStarIndex];
                    
                    const connectionsToMake = Math.min(2, cluster.length - i - 1);
                    
                    for (let j = 1; j <= connectionsToMake; j++) {
                        const nextStarIndex = cluster[(i + j) % cluster.length];
                        const nextStar = starMeshes[nextStarIndex];
                        
                        const lineGeometry = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            currentStar.data.position.x, currentStar.data.position.y, currentStar.data.position.z,
                            nextStar.data.position.x, nextStar.data.position.y, nextStar.data.position.z
                        ]);
                        lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        const color1 = new THREE.Color(currentStar.data.color);
                        const color2 = new THREE.Color(nextStar.data.color);
                        const blendedColor = color1.clone().lerp(color2, 0.5);
                        
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: blendedColor,
                            transparent: true,
                            opacity: 0.3,
                            linewidth: 1
                        });
                        
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        line.userData = {
                            clusterIndex: clusterIndex,
                            star1: currentStarIndex,
                            star2: nextStarIndex
                        };
                        
                        scene.add(line);
                        clusterLines.push(line);
                    }
                }
            });

            document.getElementById('cluster-count').textContent = starClusters.length;
        }

        function getStarClusterInfo(starData) {
            for (let i = 0; i < starClusters.length; i++) {
                const cluster = starClusters[i];
                const starIndex = starMeshes.findIndex(star => star.data.name === starData.name);
                
                if (cluster.includes(starIndex)) {
                    const clusterStars = cluster.map(index => starMeshes[index].data.name);
                    return {
                        clusterIndex: i + 1,
                        clusterSize: cluster.length,
                        clusterStars: clusterStars.filter(name => name !== starData.name)
                    };
                }
            }
            return null;
        }

        // ============== INITIALIZATION ==============
        async function init() {
            document.getElementById('loading').style.display = 'block';
            updateConnectionStatus();
            
            var image = new Image();
            image.crossOrigin = "Anonymous";
            image.src = bgUrl;
            image.onload = function() {
                initBlackHole(image);
            }
            
            const userExists = await checkExistingUser();
            const stars = await loadAllStars();
            galaxyData.stars = stars;
            galaxyData.visitCount = stars.length;
            
            initThreeJS();
            
            createCentralBlackHole();
            
            stars.forEach(star => createStarWithBloom(star));
            
            createAllPlanetarySystems();
            
            createClusterLines();
            
            updateCounters();
            setupEventListeners();
            animate();
            
            document.getElementById('loading').style.display = 'none';
            
            showMobileHint();
            
            if (!userExists) {
                setTimeout(() => {
                    document.getElementById('welcome-modal').classList.remove('hidden');
                }, 500);
            }
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000020, 1, 1000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, cameraDistance);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createBackgroundStars();
        }

        function createBackgroundStars() {
            const bgStarGeometry = new THREE.BufferGeometry();
            const bgStarCount = 1000;
            const positions = new Float32Array(bgStarCount * 3);

            for (let i = 0; i < bgStarCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 2000;
                positions[i + 1] = (Math.random() - 0.5) * 2000;
                positions[i + 2] = (Math.random() - 0.5) * 2000;
            }

            bgStarGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const bgStarMaterial = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 0.5,
                transparent: true,
                opacity: 0.6
            });

            const bgStars = new THREE.Points(bgStarGeometry, bgStarMaterial);
            scene.add(bgStars);
        }

        function createStarWithBloom(starData) {
            const coreGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(starData.color),
                transparent: false
            });
            
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            
            // Enhanced glow layers with varying colors
            const glowLayers = [];
            const baseColor = new THREE.Color(starData.color);
            const glowSizes = [1.2, 2.0, 3.5, 5.0, 8.0];
            const glowOpacities = [0.8, 0.6, 0.4, 0.2, 0.1];
            
            glowSizes.forEach((size, index) => {
                const glowGeometry = new THREE.SphereGeometry(size, 12, 12);
                
                // Create color variation for each layer
                const layerColor = baseColor.clone();
                if (index > 2) {
                    layerColor.multiplyScalar(0.7 + Math.random() * 0.3);
                }
                
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: layerColor,
                    transparent: true,
                    opacity: glowOpacities[index],
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glowLayers.push(glow);
            });
            
            // Create corona effect
            const coronaGeometry = new THREE.SphereGeometry(7, 16, 16);
            const coronaMaterial = new THREE.MeshBasicMaterial({
                color: baseColor.clone().multiplyScalar(0.5),
                transparent: true,
                opacity: 0.05,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide
            });
            const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
            
            // Create solar flare particles
            const flareGeometry = new THREE.BufferGeometry();
            const flareCount = 50;
            const flarePositions = new Float32Array(flareCount * 3);
            
            for (let i = 0; i < flareCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = 2 + Math.random() * 4;
                
                flarePositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                flarePositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                flarePositions[i * 3 + 2] = radius * Math.cos(phi);
            }
            
            flareGeometry.setAttribute('position', new THREE.BufferAttribute(flarePositions, 3));
            const flareMaterial = new THREE.PointsMaterial({
                color: baseColor,
                size: 0.3,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            const flares = new THREE.Points(flareGeometry, flareMaterial);
            
            // Create stellar wind effect
            const windGeometry = new THREE.BufferGeometry();
            const windCount = 30;
            const windPositions = new Float32Array(windCount * 3);
            
            for (let i = 0; i < windCount; i++) {
                const radius = 8 + Math.random() * 5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                windPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                windPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                windPositions[i * 3 + 2] = radius * Math.cos(phi);
            }
            
            windGeometry.setAttribute('position', new THREE.BufferAttribute(windPositions, 3));
            const windMaterial = new THREE.PointsMaterial({
                color: baseColor.clone().multiplyScalar(0.7),
                size: 0.2,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            const stellarWind = new THREE.Points(windGeometry, windMaterial);

            const starGroup = new THREE.Group();
            starGroup.add(core);
            glowLayers.forEach(glow => starGroup.add(glow));
            starGroup.add(corona);
            starGroup.add(flares);
            starGroup.add(stellarWind);
            
            starGroup.position.set(starData.position.x, starData.position.y, starData.position.z);
            starGroup.userData = starData;
            
            scene.add(starGroup);
            starMeshes.push({ 
                group: starGroup,
                core: core,
                glowLayers: glowLayers,
                corona: corona,
                flares: flares,
                stellarWind: stellarWind,
                data: starData 
            });
        }

        async function createUserStar() {
            const name = document.getElementById('user-name').value.trim();
            const color = document.getElementById('star-color').value;

            if (!name) {
                alert('Please enter your name!');
                return;
            }

            const existingStar = galaxyData.stars.find(star => star.name.toLowerCase() === name.toLowerCase());
            if (existingStar) {
                alert('A star with this name already exists! Please choose a different name.');
                return;
            }

            const starIndex = galaxyData.stars.length;
            const orbitalData = generateOrbitalData(name, starIndex);

            const starData = {
                name: name,
                color: color,
                position: orbitalData.originalPosition,
                planets: generatePlanetData(name),
                orbital: orbitalData,
                timestamp: new Date().toISOString()
            };

            const savedStar = await saveStar(starData);
            if (!savedStar) {
                alert('Error saving star. Please try again.');
                return;
            }

            await saveUser({ name: name });
            galaxyData.stars.push(savedStar);
            galaxyData.visitCount++;

            createStarWithBloom(savedStar);
            
            const newStarIndex = starMeshes.length - 1;
            const newStarObj = starMeshes[newStarIndex];
            createPlanetarySystemFromData(newStarObj, newStarIndex);
            
            createClusterLines();
            
            updateCounters();
            
            document.getElementById('welcome-modal').classList.add('hidden');
            focusOnStar(savedStar);
        }

        function focusOnStar(starData) {
            followingTarget = starData;
            
            const targetFocus = new THREE.Vector3(
                starData.position.x,
                starData.position.y,
                starData.position.z
            );
            animateFocusTo(targetFocus);
            
            console.log(`üéØ Now following: ${starData.name}`);
        }

        function focusOnBlackHole() {
            followingTarget = centralBlackHole.userData;
            
            const targetFocus = new THREE.Vector3(0, 0, 0);
            animateFocusTo(targetFocus);
            
            console.log('üéØ Now following: Lil Bingus (Black Hole)');
        }

        function stopFollowing() {
            followingTarget = null;
            console.log('üéØ Stopped following');
        }

        function animateFocusTo(targetFocus) {
            const startFocus = focusTarget.clone();
            const startTime = Date.now();
            const duration = 2000;

            function updateFocus() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easing = 1 - Math.pow(1 - progress, 3);

                focusTarget.lerpVectors(startFocus, targetFocus, easing);

                if (progress < 1) {
                    requestAnimationFrame(updateFocus);
                }
            }

            updateFocus();
        }

        function setupEventListeners() {
            let hasMouseMoved = false;
            let hasTouchMoved = false;
            let lastTouchDistance = 0;
            let touchStartTime = 0;
            
            // ============== DESKTOP MOUSE CONTROLS ==============
            document.addEventListener('mousedown', (event) => {
                if (!document.getElementById('welcome-modal').classList.contains('hidden')) {
                    return;
                }
                
                if (event.target.closest('#ui-overlay')) return;
                
                isDragging = true;
                hasMouseMoved = false;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
                document.getElementById('canvas-container').style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (event) => {
                if (!document.getElementById('welcome-modal').classList.contains('hidden')) {
                    return;
                }
                
                if (!isDragging) return;
                
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                    hasMouseMoved = true;
                }
                
                cameraRotation.y -= deltaX * rotationSpeed;
                cameraRotation.x -= deltaY * rotationSpeed;
                cameraRotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraRotation.x));
                
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            });

            document.addEventListener('mouseup', (event) => {
                if (!document.getElementById('welcome-modal').classList.contains('hidden')) {
                    return;
                }
                
                if (isDragging && !hasMouseMoved) {
                    onStarClick(event);
                }
                isDragging = false;
                hasMouseMoved = false;
                document.getElementById('canvas-container').style.cursor = 'grab';
            });

            document.addEventListener('wheel', (event) => {
                if (!document.getElementById('welcome-modal').classList.contains('hidden')) {
                    return;
                }
                
                event.preventDefault();
                cameraDistance += event.deltaY * 0.1;
                cameraDistance = Math.max(5, Math.min(200, cameraDistance));
            }, { passive: false });

            // ============== MOBILE TOUCH CONTROLS ==============
            document.addEventListener('touchstart', (event) => {
                if (!document.getElementById('welcome-modal').classList.contains('hidden')) {
                    return;
                }
                
                if (event.target.closest('#ui-overlay')) return;
                
                touchStartTime = Date.now();
                hasTouchMoved = false;
                
                if (event.touches.length === 1) {
                    isDragging = true;
                    const touch = event.touches[0];
                    previousMousePosition.x = touch.clientX;
                    previousMousePosition.y = touch.clientY;
                } else if (event.touches.length === 2) {
                    isDragging = false;
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    const dx = touch1.clientX - touch2.clientX;
                    const dy = touch1.clientY - touch2.clientY;
                    lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                }
                
                event.preventDefault();
            }, { passive: false });

            document.addEventListener('touchmove', (event) => {
                if (!document.getElementById('welcome-modal').classList.contains('hidden')) {
                    return;
                }
                
                if (event.target.closest('#ui-overlay')) return;
                
                if (event.touches.length === 1 && isDragging) {
                    const touch = event.touches[0];
                    const deltaX = touch.clientX - previousMousePosition.x;
                    const deltaY = touch.clientY - previousMousePosition.y;
                    
                    if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3) {
                        hasTouchMoved = true;
                    }
                    
                    cameraRotation.y -= deltaX * rotationSpeed * 1.5;
                    cameraRotation.x -= deltaY * rotationSpeed * 1.5;
                    cameraRotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraRotation.x));
                    
                    previousMousePosition.x = touch.clientX;
                    previousMousePosition.y = touch.clientY;
                } else if (event.touches.length === 2) {
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    const dx = touch1.clientX - touch2.clientX;
                    const dy = touch1.clientY - touch2.clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (lastTouchDistance > 0) {
                        const scale = distance / lastTouchDistance;
                        const zoomSensitivity = 1.0;
                        cameraDistance /= (scale * zoomSensitivity + (1 - zoomSensitivity));
                        cameraDistance = Math.max(5, Math.min(200, cameraDistance));
                    }
                    
                    lastTouchDistance = distance;
                    hasTouchMoved = true;
                }
                
                event.preventDefault();
            }, { passive: false });

            document.addEventListener('touchend', (event) => {
                if (!document.getElementById('welcome-modal').classList.contains('hidden')) {
                    return;
                }
                
                if (event.target.closest('#ui-overlay')) return;
                
                const touchEndTime = Date.now();
                const touchDuration = touchEndTime - touchStartTime;
                
                if (event.touches.length === 0) {
                    if (isDragging && !hasTouchMoved && touchDuration < 500) {
                        const touch = event.changedTouches[0];
                        const fakeEvent = {
                            clientX: touch.clientX,
                            clientY: touch.clientY
                        };
                        onStarClick(fakeEvent);
                    }
                    
                    isDragging = false;
                    hasTouchMoved = false;
                    lastTouchDistance = 0;
                }
                
                event.preventDefault();
            }, { passive: false });

            // Prevent default browser zoom and scroll on the canvas
            document.getElementById('canvas-container').addEventListener('touchstart', (e) => {
                e.preventDefault();
            }, { passive: false });

            document.getElementById('canvas-container').addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });

            // Prevent context menu on long press
            document.getElementById('canvas-container').addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // ============== MODAL TOUCH BLOCKING ==============
            document.getElementById('welcome-modal').addEventListener('touchstart', (e) => {
                e.stopPropagation();
            }, { passive: false });

            document.getElementById('welcome-modal').addEventListener('touchmove', (e) => {
                e.stopPropagation();
            }, { passive: false });

            document.getElementById('welcome-modal').addEventListener('touchend', (e) => {
                e.stopPropagation();
            }, { passive: false });

            // Standard event listeners
            document.getElementById('search-input').addEventListener('input', onSearch);
            document.getElementById('star-color').addEventListener('input', (e) => {
                document.getElementById('color-preview').style.backgroundColor = e.target.value;
            });

            window.addEventListener('resize', onWindowResize);
            document.getElementById('user-name').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') createUserStar();
            });

            document.addEventListener('keydown', (e) => {
                if (!document.getElementById('welcome-modal').classList.contains('hidden')) {
                    return;
                }
                
                if (e.code === 'Space') {
                    e.preventDefault();
                    stopFollowing();
                    animateFocusTo(new THREE.Vector3(0, 0, 0));
                } else if (e.code === 'KeyH' || e.code === 'KeyI') {
                    toggleUI();
                }
            });

            window.addEventListener('resize', function(event){
                if (blackholeCanvas && blackholeGl) {
                    blackholeCanvas.width = window.innerWidth;
                    blackholeCanvas.height = window.innerHeight;
                    blackholeCanvas.style.width = window.innerWidth + 'px';
                    blackholeCanvas.style.height = window.innerHeight + 'px';
                    blackholeGl.viewport(0, 0, blackholeCanvas.width, blackholeCanvas.height);
                    blackholeGl.uniform2f(locationOfResolution, blackholeCanvas.width, blackholeCanvas.height);
                    
                    if (!blackholeMouse.moved) {
                        blackholeMouse.x = window.innerWidth / 2;
                        blackholeMouse.y = window.innerHeight / 2;
                    }
                }
            });
        }

        function onStarClick(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            // Check for black hole click first
            const blackHoleIntersect = raycaster.intersectObject(centralBlackHole);
            if (blackHoleIntersect.length > 0) {
                showBlackHoleInfo();
                focusOnBlackHole();
                return;
            }

            // Check for star clicks
            const starGroups = starMeshes.map(s => s.group);
            const intersects = raycaster.intersectObjects(starGroups, true);

            if (intersects.length > 0) {
                let starGroup = intersects[0].object;
                while (starGroup.parent && !starGroup.userData.name) {
                    starGroup = starGroup.parent;
                }
                if (starGroup.userData.name) {
                    showStarInfo(starGroup.userData);
                    focusOnStar(starGroup.userData);
                }
            }
        }

        function showBlackHoleInfo() {
            const starInfoContent = document.getElementById('star-info-content');
            const isFollowing = followingTarget && followingTarget.name === 'Lil Bingus';
            const followingText = isFollowing ? 
                '<p>üìπ <strong>Camera Following</strong> <button onclick="stopFollowing()" style="margin-left: 10px; padding: 4px 8px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; color: white; cursor: pointer;">Stop Following</button></p>' : 
                '';
            
            starInfoContent.innerHTML = `
                <p class="star-name">üï≥Ô∏è Lil Bingus</p>
                <p><span class="star-color-badge" style="background: linear-gradient(45deg, #000000, #4400aa);"></span>Type: Supermassive Black Hole</p>
                <p>üìÖ Age: ${galaxyData.stars.length > 10 ? 'Ancient' : 'Eternal'}</p>
                <p>üìç Position: Center of the Galaxy (0, 0, 0)</p>
                <p>üåÄ Schwarzschild Radius: 2.5 units</p>
                <p>üî• Accretion Disk: Active with plasma jets</p>
                <p>‚ö° Hawking Radiation: Minimal but detectable</p>
                <p>üåå Gravitational Influence: Galaxy-wide</p>
                <p>üé≠ Personality: Adorably destructive</p>
                <p>üí´ Stars in Orbit: ${galaxyData.stars.length}</p>
                ${followingText}
            `;
        }

        function showStarInfo(starData) {
            const starInfoContent = document.getElementById('star-info-content');
            const createdDate = starData.timestamp ? new Date(starData.timestamp).toLocaleDateString() : 'Unknown';
            
            const clusterInfo = getStarClusterInfo(starData);
            const planetaryInfo = getStarPlanetaryInfo(starData);
            
            let clusterText = '';
            if (clusterInfo) {
                clusterText = `
                    <p>üåå Cluster: System ${clusterInfo.clusterIndex} (${clusterInfo.clusterSize} stars)</p>
                    <p>üîó Connected to: ${clusterInfo.clusterStars.slice(0, 3).join(', ')}${clusterInfo.clusterStars.length > 3 ? '...' : ''}</p>
                `;
            } else {
                clusterText = '<p>üåå Solitary star (no nearby connections)</p>';
            }

            let planetaryText = '';
            if (planetaryInfo.hasSystem) {
                planetaryText = `
                    <p>ü™ê Planets: ${planetaryInfo.planetCount}</p>
                    <p>üåç System: ${planetaryInfo.planetNames.slice(0, 4).join(', ')}${planetaryInfo.planetCount > 4 ? '...' : ''}</p>
                `;
            } else {
                planetaryText = '<p>ü™ê No planetary system</p>';
            }

            const orbital = starData.orbital;
            let orbitalText = '';
            if (orbital) {
                orbitalText = `
                    <p>üåÄ Orbit Radius: ${Math.round(orbital.radius)} units</p>
                    <p>üåÄ Orbital Speed: ${(orbital.speed * 1000).toFixed(2)} units/s</p>
                `;
            }

            const isFollowing = followingTarget && followingTarget.name === starData.name;
            const followingText = isFollowing ? 
                '<p>üìπ <strong>Camera Following</strong> <button onclick="stopFollowing()" style="margin-left: 10px; padding: 4px 8px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; color: white; cursor: pointer;">Stop Following</button></p>' : 
                '';
            
            starInfoContent.innerHTML = `
                <p class="star-name">‚≠ê ${starData.name}</p>
                <p><span class="star-color-badge" style="background-color: ${starData.color};"></span>Color: ${starData.color}</p>
                <p>üìÖ Created: ${createdDate}</p>
                <p>üìç Position: (${Math.round(starData.position.x)}, ${Math.round(starData.position.y)}, ${Math.round(starData.position.z)})</p>
                ${orbitalText}
                ${planetaryText}
                ${clusterText}
                ${followingText}
            `;
        }

        function onSearch(event) {
            const query = event.target.value.toLowerCase();
            const resultsContainer = document.getElementById('search-results');
            
            if (query.length < 2) {
                resultsContainer.innerHTML = '';
                return;
            }

            const matches = [];
            
            // Add black hole to search results if it matches
            if ('lil bingus'.includes(query) || 'black hole'.includes(query) || 'bingus'.includes(query)) {
                matches.push({
                    name: 'Lil Bingus',
                    color: '#4400aa',
                    type: 'black-hole'
                });
            }
            
            // Add matching stars
            const starMatches = galaxyData.stars.filter(star => 
                star.name.toLowerCase().includes(query)
            );
            matches.push(...starMatches);

            resultsContainer.innerHTML = matches.map(item => 
                `<div class="search-result" onclick="${item.type === 'black-hole' ? 'focusOnBlackHole()' : `focusOnStarByName('${item.name}')`}" style="color: ${item.color}">
                    ${item.type === 'black-hole' ? 'üï≥Ô∏è' : '‚≠ê'} ${item.name}
                </div>`
            ).join('');
        }

        function focusOnStarByName(name) {
            const star = galaxyData.stars.find(s => s.name === name);
            if (star) {
                focusOnStar(star);
                document.getElementById('search-input').value = '';
                document.getElementById('search-results').innerHTML = '';
            }
        }

        function updateCounters() {
            const totalPlanets = planetarySystems.reduce((total, sys) => total + sys.planets.length, 0);
            
            document.getElementById('star-count').textContent = galaxyData.stars.length;
            document.getElementById('visitor-count').textContent = galaxyData.visitCount;
            document.getElementById('cluster-count').textContent = starClusters.length;
            document.getElementById('system-count').textContent = planetarySystems.length;
            document.getElementById('planet-count').textContent = totalPlanets;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            updateStarOrbitalPositions();

            if (followingTarget) {
                focusTarget.set(
                    followingTarget.position.x,
                    followingTarget.position.y,
                    followingTarget.position.z
                );
            }

            camera.position.x = focusTarget.x + cameraDistance * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
            camera.position.y = focusTarget.y + cameraDistance * Math.sin(cameraRotation.x);
            camera.position.z = focusTarget.z + cameraDistance * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
            
            camera.lookAt(focusTarget);

            const time = Date.now() * 0.001;
            
            // Enhanced star animations
            starMeshes.forEach((starObj, index) => {
                starObj.core.rotation.y += 0.01;
                starObj.core.rotation.x += 0.005;
                
                // Animate glow layers with more variety
                starObj.glowLayers.forEach((glow, layerIndex) => {
                    const baseOpacity = [0.8, 0.6, 0.4, 0.2, 0.1][layerIndex] || 0.05;
                    glow.material.opacity = baseOpacity + Math.sin(time * 2 + index + layerIndex) * 0.3;
                    glow.rotation.y += 0.003 * (layerIndex + 1);
                    glow.rotation.x += 0.002 * (layerIndex + 1);
                    
                    const scale = 1 + Math.sin(time * 3 + index + layerIndex) * 0.15;
                    glow.scale.setScalar(scale);
                });
                
                // Animate corona
                if (starObj.corona) {
                    starObj.corona.material.opacity = 0.05 + Math.sin(time * 0.5 + index) * 0.03;
                    starObj.corona.rotation.y += 0.001;
                    const coronaScale = 1 + Math.sin(time * 0.3 + index) * 0.1;
                    starObj.corona.scale.setScalar(coronaScale);
                }
                
                // Animate solar flares
                if (starObj.flares) {
                    starObj.flares.material.opacity = 0.6 + Math.sin(time * 4 + index) * 0.4;
                    starObj.flares.rotation.y += 0.02;
                    starObj.flares.rotation.x += 0.01;
                }
                
                // Animate stellar wind
                if (starObj.stellarWind) {
                    starObj.stellarWind.material.opacity = 0.3 + Math.sin(time * 1.5 + index) * 0.2;
                    starObj.stellarWind.rotation.y -= 0.005;
                    const windScale = 1 + Math.sin(time * 2 + index) * 0.2;
                    starObj.stellarWind.scale.setScalar(windScale);
                }
            });

            // Enhanced black hole animations
            if (centralBlackHole) {
                centralBlackHole.rotation.y += 0.005;
                
                if (centralBlackHole.userData.glowLayers) {
                    centralBlackHole.userData.glowLayers.forEach((glow, index) => {
                        const baseOpacity = [0.15, 0.1, 0.06, 0.03][index] || 0.01;
                        glow.material.opacity = baseOpacity + Math.sin(time * 0.5 + index) * 0.05;
                        glow.rotation.y += 0.001 * (index + 1);
                        glow.rotation.x += 0.0005 * (index + 1);
                        
                        const scale = 1 + Math.sin(time * 0.8 + index) * 0.1;
                        glow.scale.setScalar(scale);
                    });
                }
                
                // Animate accretion disk
                if (centralBlackHole.userData.accretionDisk) {
                    const disk = centralBlackHole.userData.accretionDisk;
                    disk.rotation.z += 0.02;
                    disk.material.opacity = 0.3 + Math.sin(time * 1.2) * 0.15;
                }
                
                // Animate inner disk
                if (centralBlackHole.userData.innerDisk) {
                    const innerDisk = centralBlackHole.userData.innerDisk;
                    innerDisk.rotation.z += 0.05;
                    innerDisk.material.opacity = 0.6 + Math.sin(time * 2) * 0.3;
                }
                
                // Animate particle jets
                if (centralBlackHole.userData.jetParticles) {
                    centralBlackHole.userData.jetParticles.forEach((jet, index) => {
                        jet.material.opacity = 0.8 + Math.sin(time * 3 + index) * 0.2;
                        jet.rotation.y += 0.01;
                        
                        // Update particle positions for flowing effect
                        const positions = jet.geometry.attributes.position.array;
                        for (let i = 0; i < positions.length; i += 3) {
                            positions[i] += (Math.random() - 0.5) * 0.02;
                            positions[i + 2] += (Math.random() - 0.5) * 0.02;
                        }
                        jet.geometry.attributes.position.needsUpdate = true;
                    });
                }
            }

            clusterLines.forEach((line, index) => {
                if (line.material) {
                    const baseOpacity = 0.3;
                    line.material.opacity = baseOpacity + Math.sin(time * 0.5 + index * 0.1) * 0.15;
                }
            });

            animatePlanets();

            renderer.render(scene, camera);
        }

        // Start the application
        init();

        // Make functions globally available for buttons
        window.toggleUI = toggleUI;
        window.stopFollowing = stopFollowing;
        window.createUserStar = createUserStar;
        window.focusOnStarByName = focusOnStarByName;
        window.focusOnBlackHole = focusOnBlackHole;
    </script>
</body>
</html>