<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Albert's Galaxy - Leave Your Mark!</title>
    
    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            position: absolute;
            top: 0px;
            left: 0px;
            right: 0px;
            bottom: 0px;
            padding: 0px;
            margin: 0px;
            overflow: hidden;
            display: flex;
            height: 100%;
            width: 100%;
            background-color: #000;
            color: white;
            font-family: 'Arial', sans-serif;
        }

        /* Black hole shader background */
        #blackhole-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            margin: auto auto;
        }

        /* Three.js star galaxy layer */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* Crystal Glass Panel Style */
        .liquid-crystal-panel {
            position: relative;
            background: inherit;
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 8px;
            padding: 20px;
            pointer-events: auto;
            overflow: hidden;
            box-shadow: 
                0 8px 32px 0 rgba(31, 38, 135, 0.37),
                inset 0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        .liquid-crystal-panel::before {
            content: '';
            position: absolute;
            top: -50px;
            left: -50px;
            right: -50px;
            bottom: -50px;
            background: inherit;
            z-index: -1;
            filter: blur(20px);
        }

        .liquid-crystal-panel::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            pointer-events: none;
        }

        #star-counter {
            position: absolute;
            bottom: 20px;
            right: 20px;
        }

        #search-container {
            position: absolute;
            top: 20px;
            right: 20px;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            max-width: 250px;
        }

        #star-details {
            position: absolute;
            bottom: 20px;
            left: 20px;
            max-width: 250px;
            min-width: 200px;
        }

        /* Clean Input Styles */
        #search-input, #user-name {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 12px;
            color: white;
            width: 100%;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        #search-input:focus, #user-name:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.4);
            background: rgba(255, 255, 255, 0.15);
        }

        #search-input::placeholder, #user-name::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        #search-results {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .search-result {
            padding: 8px;
            cursor: pointer;
            border-radius: 4px;
            margin: 3px 0;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .search-result:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        #star-info-content {
            margin-top: 10px;
            position: relative;
            z-index: 10;
        }

        #star-info-content p {
            margin: 8px 0;
            font-size: 14px;
        }

        .star-name {
            color: #ffffff;
            font-weight: bold;
            font-size: 16px;
        }

        .star-color-badge {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.3);
            margin-right: 8px;
            vertical-align: middle;
        }

        /* Enhanced Modal Styles */
        #welcome-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            pointer-events: auto;
        }

        .modal-content {
            background: inherit;
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(20px);
            box-shadow: 
                0 8px 32px 0 rgba(31, 38, 135, 0.37),
                inset 0 0 0 1px rgba(255, 255, 255, 0.1);
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: -50px;
            left: -50px;
            right: -50px;
            bottom: -50px;
            background: inherit;
            z-index: -1;
            filter: blur(20px);
        }

        .modal-content::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            pointer-events: none;
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: #ffffff;
            position: relative;
            z-index: 10;
        }

        .modal-content input[type="color"] {
            width: 60px;
            height: 40px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: transparent;
            cursor: pointer;
            margin: 10px;
        }

        .modal-content button {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin-top: 20px;
            transition: all 0.3s ease;
            position: relative;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        .modal-content button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.05);
        }

        #color-preview {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            margin: 15px auto;
        }

        .hidden {
            display: none !important;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 20px;
            font-weight: normal;
            z-index: 500;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 0.7;
            }
            50% {
                opacity: 1;
            }
        }

        /* Clean scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <!-- Black Hole Shader Scripts -->
    <script id="2d-fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif
        #define PI 3.14159265359
        uniform sampler2D u_image;
        varying vec2 v_texCoord;
        uniform vec2 u_resolution;
        uniform vec2 u_mouse;
        uniform float u_mass;
        uniform float u_time;
        uniform float u_clickedTime;
        vec2 rotate(vec2 mt, vec2 st, float angle){
        float cos = cos((angle + u_clickedTime) * PI);
        float sin = sin(angle * 0.0);
        float nx = (cos * (st.x - mt.x)) + (sin * (st.y - mt.y)) + mt.x;
        float ny = (cos * (st.y - mt.y)) - (sin * (st.x - mt.x)) + mt.y;
        return vec2(nx, ny);
        }
        void main() {
        vec2 st = gl_FragCoord.xy / u_resolution.xy;
        vec2 mt = vec2(u_mouse.x / u_resolution.x, 1.0 - (u_mouse.y / u_resolution.y));
        
        float dx = st.x - mt.x;
        float dy = st.y - mt.y;
        float dist = sqrt(dx * dx + dy * dy);
        float pull = u_mass / (dist * dist);
        vec3 color = vec3(0.0);
        vec2 r = rotate(mt,st,pull);
        vec4 imgcolor = texture2D(u_image, r);
        color = vec3(
        (imgcolor.x - (pull * 0.25)),
        (imgcolor.y - (pull * 0.25)),
        (imgcolor.z - (pull * 0.25))
        );
        gl_FragColor = vec4(color,1.);
        }
    </script>
    <script id="2d-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;
        void main() {
        gl_Position = vec4(a_position, 0, 1);
        v_texCoord = a_texCoord;
        }
    </script>

    <!-- Black hole background layer -->
    <canvas id="blackhole-canvas"></canvas>
    
    <div id="loading">üåü Loading galaxy...</div>
    
    <!-- Three.js star galaxy layer -->
    <div id="canvas-container"></div>
    
    <div id="ui-overlay">
        <div id="instructions" class="liquid-crystal-panel">
            <h3>üåü Albert's Galaxy</h3>
            <p><strong>Controls:</strong></p>
            <p>‚Ä¢ Drag: Rotate view</p>
            <p>‚Ä¢ Scroll: Zoom in/out</p>
            <p>‚Ä¢ Click stars to focus</p>
            <p>‚Ä¢ Space: Reset to center</p>
            <p><br><em>Welcome to the galaxy! Your star will be saved forever and connected to nearby stars in clusters.</em></p>
        </div>

        <div id="search-container" class="liquid-crystal-panel">
            <input type="text" id="search-input" placeholder="Search stars by name...">
            <div id="search-results"></div>
        </div>

        <div id="star-counter" class="liquid-crystal-panel">
            <h3>‚≠ê Galaxy Stats</h3>
            <p>Status: <span id="connection-status">üîÑ Connecting...</span></p>
            <p>Total Stars: <span id="star-count">0</span></p>
            <p>Star Clusters: <span id="cluster-count">0</span></p>
            <p>Unique Visitors: <span id="visitor-count">0</span></p>
        </div>

        <div id="star-details" class="liquid-crystal-panel">
            <h3>üåü Star Details</h3>
            <div id="star-info-content">
                <p><em>Click on a star to see its details and cluster connections</em></p>
            </div>
        </div>
    </div>

    <!-- Welcome Modal -->
    <div id="welcome-modal" class="hidden">
        <div class="modal-content">
            <h2>üåü Welcome to the Albert Galaxy!</h2>
            <p>Leave your mark in the cosmos by creating your own star.</p>
            
            <input type="text" id="user-name" placeholder="Enter your name" maxlength="20">
            
            <div>
                <label for="star-color">Choose your star color:</label>
                <input type="color" id="star-color" value="#ffffff">
                <div id="color-preview" style="background-color: #ffffff;"></div>
            </div>
            
            <button id="create-star" onclick="createUserStar()">Create My Star ‚ú®</button>
        </div>
    </div>

    <script>
        // ============== BLACK HOLE SHADER CONFIGURATION ==============
        var bgUrl = 'background.jpg';
        var blackholeMass = 1500;
        var curblackholeMass = 0;
        var blackholeCanvas, blackholeGl;
        var shaderScript, shaderSource, vertexShader, fragmentShader, buffer;
        var locationOfTime, locationOfResolution, locationOfMouse, locationOfMass, locationOfclickedTime;
        var originY = window.innerHeight, originX = window.innerWidth;
        var blackholeMouse;
        var startTime = new Date().getTime();
        var currentTime = 0;

        // ============== SUPABASE CONFIGURATION ==============
        const SUPABASE_URL = 'https://kncwqtqmbyukguuargsg.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtuY3dxdHFtYnl1a2d1dWFyZ3NnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk3NDQ4MDUsImV4cCI6MjA2NTMyMDgwNX0.WvxeazNz2y-F57JE0fvT4XVXkEMZQ-R_sviYaSrRuNg';

        let supabaseClient = null;
        let isOnlineMode = false;

        try {
            if (typeof window.supabase !== 'undefined' && window.supabase.createClient) {
                const { createClient } = window.supabase;
                supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                isOnlineMode = true;
                console.log('üü¢ Online mode: Connected to Supabase');
            } else {
                throw new Error('Supabase library not found');
            }
        } catch (error) {
            console.log('üü° Offline mode: Supabase connection failed', error);
            isOnlineMode = false;
        }

        function updateConnectionStatus() {
            const statusElement = document.getElementById('connection-status');
            if (isOnlineMode) {
                statusElement.innerHTML = 'üü¢ Online (Database)';
                statusElement.style.color = '#90EE90';
            } else {
                statusElement.innerHTML = 'üü° Offline (Local)';
                statusElement.style.color = '#FFD700';
            }
        }

        // ============== DATA MANAGEMENT ==============
        let galaxyData = { stars: [], visitCount: 0 };
        let scene, camera, renderer, composer;
        let starMeshes = [];
        let starClusters = [];
        let clusterLines = [];
        let selectedStar = null;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraDistance = 50;
        let cameraRotation = { x: 0, y: 0 };
        let focusTarget = new THREE.Vector3(0, 0, 0);
        const rotationSpeed = 0.005;
        let currentUser = null;

        // ============== BLACK HOLE SHADER FUNCTIONS ==============
        function initBlackHole(image) {
            blackholeCanvas = document.getElementById('blackhole-canvas');
            blackholeGl = blackholeCanvas.getContext('webgl') || blackholeCanvas.getContext('experimental-webgl');
            
            blackholeCanvas.width = window.innerWidth;
            blackholeCanvas.height = window.innerHeight;
            blackholeCanvas.style.width = window.innerWidth + 'px';
            blackholeCanvas.style.height = window.innerHeight + 'px';
            
            blackholeMouse = {x: window.innerWidth/2, y: window.innerHeight/2, moved: false};
            
            $(document).mousemove(function(e) {
                blackholeMouse.x = e.pageX;
                blackholeMouse.y = e.pageY;
                blackholeMouse.moved = true;
            });

            blackholeGl.viewport(0, 0, blackholeCanvas.width, blackholeCanvas.height);
            
            buffer = blackholeGl.createBuffer();
            blackholeGl.bindBuffer(blackholeGl.ARRAY_BUFFER, buffer);
            blackholeGl.bufferData(
                blackholeGl.ARRAY_BUFFER,
                new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]),
                blackholeGl.STATIC_DRAW
            );

            shaderScript = document.getElementById("2d-vertex-shader");
            shaderSource = shaderScript.text;
            vertexShader = blackholeGl.createShader(blackholeGl.VERTEX_SHADER);
            blackholeGl.shaderSource(vertexShader, shaderSource);
            blackholeGl.compileShader(vertexShader);

            shaderScript = document.getElementById("2d-fragment-shader");
            shaderSource = shaderScript.text;
            fragmentShader = blackholeGl.createShader(blackholeGl.FRAGMENT_SHADER);
            blackholeGl.shaderSource(fragmentShader, shaderSource);
            blackholeGl.compileShader(fragmentShader);

            program = blackholeGl.createProgram();
            blackholeGl.attachShader(program, vertexShader);
            blackholeGl.attachShader(program, fragmentShader);
            blackholeGl.linkProgram(program);
            blackholeGl.useProgram(program);

            locationOfResolution = blackholeGl.getUniformLocation(program, "u_resolution");
            locationOfMouse = blackholeGl.getUniformLocation(program, "u_mouse");
            locationOfMass = blackholeGl.getUniformLocation(program, "u_mass");
            locationOfTime = blackholeGl.getUniformLocation(program, "u_time");
            locationOfclickedTime = blackholeGl.getUniformLocation(program, "u_clickedTime");

            blackholeGl.uniform2f(locationOfResolution, blackholeCanvas.width, blackholeCanvas.height);
            blackholeGl.uniform2f(locationOfMouse, blackholeMouse.x, blackholeMouse.y);
            blackholeGl.uniform1f(locationOfMass, curblackholeMass*0.00001);
            blackholeGl.uniform1f(locationOfTime, currentTime);
            blackholeGl.uniform1f(locationOfclickedTime, 0);

            var texCoordLocation = blackholeGl.getAttribLocation(program, "a_texCoord");
            var texCoordBuffer = blackholeGl.createBuffer();
            blackholeGl.bindBuffer(blackholeGl.ARRAY_BUFFER, texCoordBuffer);
            blackholeGl.bufferData(blackholeGl.ARRAY_BUFFER, new Float32Array([
                -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]),
                blackholeGl.STATIC_DRAW);
            blackholeGl.enableVertexAttribArray(texCoordLocation);
            blackholeGl.vertexAttribPointer(texCoordLocation, 2, blackholeGl.FLOAT, false, 0, 0);

            var texture = blackholeGl.createTexture();
            blackholeGl.bindTexture(blackholeGl.TEXTURE_2D, texture);
            blackholeGl.texParameteri(blackholeGl.TEXTURE_2D, blackholeGl.TEXTURE_WRAP_S, blackholeGl.CLAMP_TO_EDGE);
            blackholeGl.texParameteri(blackholeGl.TEXTURE_2D, blackholeGl.TEXTURE_WRAP_T, blackholeGl.CLAMP_TO_EDGE);
            blackholeGl.texParameteri(blackholeGl.TEXTURE_2D, blackholeGl.TEXTURE_MIN_FILTER, blackholeGl.NEAREST);
            blackholeGl.texParameteri(blackholeGl.TEXTURE_2D, blackholeGl.TEXTURE_MAG_FILTER, blackholeGl.NEAREST);
            blackholeGl.texImage2D(blackholeGl.TEXTURE_2D, 0, blackholeGl.RGBA, blackholeGl.RGBA, blackholeGl.UNSIGNED_BYTE, image);

            renderBlackHole();
        }

        function renderBlackHole() {
            var now = new Date().getTime();
            currentTime = (now - startTime) / 1000;
            
            if(curblackholeMass < blackholeMass - 50){
                curblackholeMass += (blackholeMass-curblackholeMass) * 0.03;
            }
            
            if(blackholeMouse.moved == false){
                blackholeMouse.x = (window.innerWidth/2) + Math.sin(currentTime * 0.6) * (window.innerWidth * 0.35);
                blackholeMouse.y = (window.innerHeight/2) + Math.sin(currentTime * 0.7) * (window.innerHeight * 0.25);
            }

            blackholeGl.uniform1f(locationOfMass, curblackholeMass*0.00001);
            blackholeGl.uniform2f(locationOfMouse, blackholeMouse.x, blackholeMouse.y);
            blackholeGl.uniform1f(locationOfTime, currentTime);
            blackholeGl.uniform1f(locationOfclickedTime, 0);

            window.requestAnimationFrame(renderBlackHole, blackholeCanvas);
            
            positionLocation = blackholeGl.getAttribLocation(program, "a_position");
            blackholeGl.enableVertexAttribArray(positionLocation);
            blackholeGl.vertexAttribPointer(positionLocation, 2, blackholeGl.FLOAT, false, 0, 0);
            blackholeGl.drawArrays(blackholeGl.TRIANGLES, 0, 6);
        }

        // ============== DATABASE FUNCTIONS ==============
        async function checkExistingUser() {
            const fingerprint = await generateUserFingerprint();
            
            if (isOnlineMode) {
                try {
                    const { data, error } = await supabaseClient
                        .from('galaxy_users')
                        .select('*')
                        .eq('fingerprint', fingerprint)
                        .single();
                    
                    if (data && !error) {
                        currentUser = data;
                        return true;
                    }
                } catch (error) {
                    console.log('User not found in database');
                }
            } else {
                const existingUser = JSON.parse(localStorage.getItem('galaxy_user_' + fingerprint) || 'null');
                if (existingUser) {
                    currentUser = existingUser;
                    return true;
                }
            }
            
            return false;
        }

        async function generateUserFingerprint() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('Browser fingerprint', 2, 2);
            
            const fingerprint = [
                navigator.userAgent,
                navigator.language,
                screen.width + 'x' + screen.height,
                new Date().getTimezoneOffset(),
                canvas.toDataURL()
            ].join('|');
            
            let hash = 0;
            for (let i = 0; i < fingerprint.length; i++) {
                const char = fingerprint.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            
            return Math.abs(hash).toString();
        }

        async function saveUser(userData) {
            const fingerprint = await generateUserFingerprint();
            const userRecord = {
                fingerprint: fingerprint,
                name: userData.name,
                created_at: new Date().toISOString()
            };

            if (isOnlineMode) {
                try {
                    const { data, error } = await supabaseClient
                        .from('galaxy_users')
                        .insert([userRecord])
                        .select()
                        .single();
                    
                    if (!error) {
                        currentUser = data;
                        return true;
                    }
                } catch (error) {
                    console.error('Error saving user:', error);
                }
            } else {
                localStorage.setItem('galaxy_user_' + fingerprint, JSON.stringify(userRecord));
                currentUser = userRecord;
                return true;
            }
            
            return false;
        }

        async function loadAllStars() {
            if (isOnlineMode) {
                try {
                    console.log('üîÑ Loading stars from database...');
                    const { data, error } = await supabaseClient
                        .from('galaxy_stars')
                        .select('*')
                        .order('created_at', { ascending: true });
                    
                    if (error) {
                        console.error('‚ùå Database error:', error);
                        isOnlineMode = false;
                        updateConnectionStatus();
                        return [{ name: "PointZero", color: "#ff6b6b", position: { x: 0, y: 0, z: 0 }, timestamp: new Date().toISOString() }];
                    }
                    
                    if (data) {
                        console.log(`‚úÖ Loaded ${data.length} stars from database`);
                        return data.map(star => ({
                            id: star.id,
                            name: star.name,
                            color: star.color,
                            position: star.position,
                            timestamp: star.created_at
                        }));
                    }
                } catch (error) {
                    console.error('‚ùå Error loading stars:', error);
                    isOnlineMode = false;
                    updateConnectionStatus();
                }
            } else {
                const starsData = localStorage.getItem('galaxy_stars');
                if (starsData) {
                    return JSON.parse(starsData);
                }
            }
            
            return [{ name: "PointZero", color: "#ff6b6b", position: { x: 0, y: 0, z: 0 }, timestamp: new Date().toISOString() }];
        }

        async function saveStar(starData) {
            if (isOnlineMode) {
                try {
                    console.log('üíæ Saving star to database:', starData.name);
                    const { data, error } = await supabaseClient
                        .from('galaxy_stars')
                        .insert([{
                            name: starData.name,
                            color: starData.color,
                            position: starData.position,
                            created_at: starData.timestamp
                        }])
                        .select()
                        .single();
                    
                    if (error) {
                        console.error('‚ùå Error saving star:', error);
                        isOnlineMode = false;
                        updateConnectionStatus();
                        return await saveStar(starData);
                    }
                    
                    if (data) {
                        console.log('‚úÖ Star saved successfully!');
                        return { ...starData, id: data.id };
                    }
                } catch (error) {
                    console.error('‚ùå Database connection error:', error);
                    isOnlineMode = false;
                    updateConnectionStatus();
                    return await saveStar(starData);
                }
            } else {
                const existingStars = JSON.parse(localStorage.getItem('galaxy_stars') || '[]');
                const newStar = { ...starData, id: Date.now() };
                existingStars.push(newStar);
                localStorage.setItem('galaxy_stars', JSON.stringify(existingStars));
                console.log('üíæ Star saved to localStorage (offline mode)');
                return newStar;
            }
            
            return null;
        }

        // ============== STAR CLUSTER FUNCTIONS ==============
        function calculateDistance(pos1, pos2) {
            const dx = pos1.x - pos2.x;
            const dy = pos1.y - pos2.y;
            const dz = pos1.z - pos2.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        function findStarClusters() {
            const MAX_CLUSTER_DISTANCE = 25; // Maximum distance for stars to be in same cluster
            const MIN_CLUSTER_SIZE = 3;
            const MAX_CLUSTER_SIZE = 6;
            const clusters = [];
            const usedStars = new Set();

            // Find clusters of nearby stars
            for (let i = 0; i < starMeshes.length; i++) {
                if (usedStars.has(i)) continue;

                const currentStar = starMeshes[i];
                const cluster = [i];
                usedStars.add(i);

                // Find nearby stars
                for (let j = 0; j < starMeshes.length; j++) {
                    if (i === j || usedStars.has(j) || cluster.length >= MAX_CLUSTER_SIZE) continue;

                    const distance = calculateDistance(
                        currentStar.data.position,
                        starMeshes[j].data.position
                    );

                    if (distance <= MAX_CLUSTER_DISTANCE) {
                        cluster.push(j);
                        usedStars.add(j);
                    }
                }

                // Only create cluster if it has minimum required stars
                if (cluster.length >= MIN_CLUSTER_SIZE) {
                    clusters.push(cluster);
                }
            }

            return clusters;
        }

        function createClusterLines() {
            // Clear existing cluster lines
            clusterLines.forEach(line => scene.remove(line));
            clusterLines = [];

            starClusters = findStarClusters();
            console.log(`üåå Created ${starClusters.length} star clusters`);

            starClusters.forEach((cluster, clusterIndex) => {
                // Create lines between stars in cluster (not all-to-all, but a nice pattern)
                for (let i = 0; i < cluster.length; i++) {
                    const currentStarIndex = cluster[i];
                    const currentStar = starMeshes[currentStarIndex];
                    
                    // Connect to next 1-2 stars in cluster to avoid too many lines
                    const connectionsToMake = Math.min(2, cluster.length - i - 1);
                    
                    for (let j = 1; j <= connectionsToMake; j++) {
                        const nextStarIndex = cluster[(i + j) % cluster.length];
                        const nextStar = starMeshes[nextStarIndex];
                        
                        const lineGeometry = new THREE.BufferGeometry();
                        const positions = new Float32Array([
                            currentStar.data.position.x, currentStar.data.position.y, currentStar.data.position.z,
                            nextStar.data.position.x, nextStar.data.position.y, nextStar.data.position.z
                        ]);
                        lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                        
                        // Create line with subtle color - blend of the two connected stars
                        const color1 = new THREE.Color(currentStar.data.color);
                        const color2 = new THREE.Color(nextStar.data.color);
                        const blendedColor = color1.clone().lerp(color2, 0.5);
                        
                        const lineMaterial = new THREE.LineBasicMaterial({
                            color: blendedColor,
                            transparent: true,
                            opacity: 0.3,
                            linewidth: 1
                        });
                        
                        const line = new THREE.Line(lineGeometry, lineMaterial);
                        line.userData = {
                            clusterIndex: clusterIndex,
                            star1: currentStarIndex,
                            star2: nextStarIndex
                        };
                        
                        scene.add(line);
                        clusterLines.push(line);
                    }
                }
            });

            // Update cluster count in UI
            document.getElementById('cluster-count').textContent = starClusters.length;
        }

        function getStarClusterInfo(starData) {
            // Find which cluster this star belongs to
            for (let i = 0; i < starClusters.length; i++) {
                const cluster = starClusters[i];
                const starIndex = starMeshes.findIndex(star => star.data.name === starData.name);
                
                if (cluster.includes(starIndex)) {
                    const clusterStars = cluster.map(index => starMeshes[index].data.name);
                    return {
                        clusterIndex: i + 1,
                        clusterSize: cluster.length,
                        clusterStars: clusterStars.filter(name => name !== starData.name)
                    };
                }
            }
            return null;
        }

        // ============== INITIALIZATION ==============
        async function init() {
            document.getElementById('loading').style.display = 'block';
            updateConnectionStatus();
            
            var image = new Image();
            image.crossOrigin = "Anonymous";
            image.src = bgUrl;
            image.onload = function() {
                initBlackHole(image);
            }
            
            const userExists = await checkExistingUser();
            const stars = await loadAllStars();
            galaxyData.stars = stars;
            galaxyData.visitCount = stars.length;
            
            initThreeJS();
            stars.forEach(star => createStarWithBloom(star));
            
            // Create star clusters after all stars are loaded
            createClusterLines();
            
            updateCounters();
            setupEventListeners();
            animate();
            
            document.getElementById('loading').style.display = 'none';
            
            if (!userExists) {
                setTimeout(() => {
                    document.getElementById('welcome-modal').classList.remove('hidden');
                }, 500);
            }
        }

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000020, 1, 1000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, cameraDistance);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createBackgroundStars();
        }

        function createBackgroundStars() {
            const bgStarGeometry = new THREE.BufferGeometry();
            const bgStarCount = 1000;
            const positions = new Float32Array(bgStarCount * 3);

            for (let i = 0; i < bgStarCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 2000;
                positions[i + 1] = (Math.random() - 0.5) * 2000;
                positions[i + 2] = (Math.random() - 0.5) * 2000;
            }

            bgStarGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const bgStarMaterial = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 0.5,
                transparent: true,
                opacity: 0.6
            });

            const bgStars = new THREE.Points(bgStarGeometry, bgStarMaterial);
            scene.add(bgStars);
        }

        function createStarWithBloom(starData) {
            const coreGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: new THREE.Color(starData.color),
                transparent: false
            });
            
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            
            const glowLayers = [];
            const glowSizes = [1.2, 2.0, 3.5, 5.0];
            const glowOpacities = [0.8, 0.6, 0.3, 0.1];
            
            glowSizes.forEach((size, index) => {
                const glowGeometry = new THREE.SphereGeometry(size, 12, 12);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(starData.color),
                    transparent: true,
                    opacity: glowOpacities[index],
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glowLayers.push(glow);
            });

            const starGroup = new THREE.Group();
            starGroup.add(core);
            glowLayers.forEach(glow => starGroup.add(glow));
            
            starGroup.position.set(starData.position.x, starData.position.y, starData.position.z);
            starGroup.userData = starData;
            
            scene.add(starGroup);
            starMeshes.push({ 
                group: starGroup,
                core: core,
                glowLayers: glowLayers,
                data: starData 
            });
        }

        async function createUserStar() {
            const name = document.getElementById('user-name').value.trim();
            const color = document.getElementById('star-color').value;

            if (!name) {
                alert('Please enter your name!');
                return;
            }

            const existingStar = galaxyData.stars.find(star => star.name.toLowerCase() === name.toLowerCase());
            if (existingStar) {
                alert('A star with this name already exists! Please choose a different name.');
                return;
            }

            const starData = {
                name: name,
                color: color,
                position: generateStarPosition(),
                timestamp: new Date().toISOString()
            };

            const savedStar = await saveStar(starData);
            if (!savedStar) {
                alert('Error saving star. Please try again.');
                return;
            }

            await saveUser({ name: name });
            galaxyData.stars.push(savedStar);
            galaxyData.visitCount++;

            createStarWithBloom(savedStar);
            
            // Recreate clusters to include the new star
            createClusterLines();
            
            updateCounters();
            
            document.getElementById('welcome-modal').classList.add('hidden');
            focusOnStar(savedStar);
        }

        function generateStarPosition() {
            const radius = Math.random() * 40 + 10;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;

            return {
                x: radius * Math.sin(phi) * Math.cos(theta),
                y: radius * Math.sin(phi) * Math.sin(theta),
                z: radius * Math.cos(phi)
            };
        }

        function focusOnStar(starData) {
            const targetFocus = new THREE.Vector3(
                starData.position.x,
                starData.position.y,
                starData.position.z
            );
            animateFocusTo(targetFocus);
        }

        function animateFocusTo(targetFocus) {
            const startFocus = focusTarget.clone();
            const startTime = Date.now();
            const duration = 2000;

            function updateFocus() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easing = 1 - Math.pow(1 - progress, 3);

                focusTarget.lerpVectors(startFocus, targetFocus, easing);

                if (progress < 1) {
                    requestAnimationFrame(updateFocus);
                }
            }

            updateFocus();
        }

        function setupEventListeners() {
            let hasMouseMoved = false;
            
            document.addEventListener('mousedown', (event) => {
                if (event.target.closest('#ui-overlay')) return;
                isDragging = true;
                hasMouseMoved = false;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
                document.getElementById('canvas-container').style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (event) => {
                if (!isDragging) return;
                
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                    hasMouseMoved = true;
                }
                
                cameraRotation.y -= deltaX * rotationSpeed;
                cameraRotation.x -= deltaY * rotationSpeed;
                cameraRotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraRotation.x));
                
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            });

            document.addEventListener('mouseup', (event) => {
                if (isDragging && !hasMouseMoved) {
                    onStarClick(event);
                }
                isDragging = false;
                hasMouseMoved = false;
                document.getElementById('canvas-container').style.cursor = 'grab';
            });

            document.addEventListener('wheel', (event) => {
                cameraDistance += event.deltaY * 0.1;
                cameraDistance = Math.max(5, Math.min(200, cameraDistance));
            });

            document.getElementById('search-input').addEventListener('input', onSearch);
            document.getElementById('star-color').addEventListener('input', (e) => {
                document.getElementById('color-preview').style.backgroundColor = e.target.value;
            });

            window.addEventListener('resize', onWindowResize);
            document.getElementById('user-name').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') createUserStar();
            });

            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    animateFocusTo(new THREE.Vector3(0, 0, 0));
                }
            });

            window.addEventListener('resize', function(event){
                if (blackholeCanvas && blackholeGl) {
                    blackholeCanvas.width = window.innerWidth;
                    blackholeCanvas.height = window.innerHeight;
                    blackholeCanvas.style.width = window.innerWidth + 'px';
                    blackholeCanvas.style.height = window.innerHeight + 'px';
                    blackholeGl.viewport(0, 0, blackholeCanvas.width, blackholeCanvas.height);
                    blackholeGl.uniform2f(locationOfResolution, blackholeCanvas.width, blackholeCanvas.height);
                    
                    if (!blackholeMouse.moved) {
                        blackholeMouse.x = window.innerWidth / 2;
                        blackholeMouse.y = window.innerHeight / 2;
                    }
                }
            });
        }

        function onStarClick(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const starGroups = starMeshes.map(s => s.group);
            const intersects = raycaster.intersectObjects(starGroups, true);

            if (intersects.length > 0) {
                let starGroup = intersects[0].object;
                while (starGroup.parent && !starGroup.userData.name) {
                    starGroup = starGroup.parent;
                }
                if (starGroup.userData.name) {
                    showStarInfo(starGroup.userData);
                    focusOnStar(starGroup.userData);
                }
            }
        }

        function showStarInfo(starData) {
            const starInfoContent = document.getElementById('star-info-content');
            const createdDate = starData.timestamp ? new Date(starData.timestamp).toLocaleDateString() : 'Unknown';
            
            // Get cluster information
            const clusterInfo = getStarClusterInfo(starData);
            
            let clusterText = '';
            if (clusterInfo) {
                clusterText = `
                    <p>üåå Cluster: System ${clusterInfo.clusterIndex} (${clusterInfo.clusterSize} stars)</p>
                    <p>üîó Connected to: ${clusterInfo.clusterStars.slice(0, 3).join(', ')}${clusterInfo.clusterStars.length > 3 ? '...' : ''}</p>
                `;
            } else {
                clusterText = '<p>üåå Solitary star (no nearby connections)</p>';
            }
            
            starInfoContent.innerHTML = `
                <p class="star-name">‚≠ê ${starData.name}</p>
                <p><span class="star-color-badge" style="background-color: ${starData.color};"></span>Color: ${starData.color}</p>
                <p>üìÖ Created: ${createdDate}</p>
                <p>üìç Position: (${Math.round(starData.position.x)}, ${Math.round(starData.position.y)}, ${Math.round(starData.position.z)})</p>
                ${clusterText}
            `;
        }

        function onSearch(event) {
            const query = event.target.value.toLowerCase();
            const resultsContainer = document.getElementById('search-results');
            
            if (query.length < 2) {
                resultsContainer.innerHTML = '';
                return;
            }

            const matches = galaxyData.stars.filter(star => 
                star.name.toLowerCase().includes(query)
            );

            resultsContainer.innerHTML = matches.map(star => 
                `<div class="search-result" onclick="focusOnStarByName('${star.name}')" style="color: ${star.color}">
                    ‚≠ê ${star.name}
                </div>`
            ).join('');
        }

        function focusOnStarByName(name) {
            const star = galaxyData.stars.find(s => s.name === name);
            if (star) {
                focusOnStar(star);
                document.getElementById('search-input').value = '';
                document.getElementById('search-results').innerHTML = '';
            }
        }

        function updateCounters() {
            document.getElementById('star-count').textContent = galaxyData.stars.length;
            document.getElementById('visitor-count').textContent = galaxyData.visitCount;
            document.getElementById('cluster-count').textContent = starClusters.length;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            camera.position.x = focusTarget.x + cameraDistance * Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x);
            camera.position.y = focusTarget.y + cameraDistance * Math.sin(cameraRotation.x);
            camera.position.z = focusTarget.z + cameraDistance * Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x);
            
            camera.lookAt(focusTarget);

            const time = Date.now() * 0.001;
            
            starMeshes.forEach((starObj, index) => {
                starObj.core.rotation.y += 0.01;
                starObj.core.rotation.x += 0.005;
                
                starObj.glowLayers.forEach((glow, layerIndex) => {
                    const baseOpacity = [0.8, 0.6, 0.3, 0.1][layerIndex] || 0.05;
                    glow.material.opacity = baseOpacity + Math.sin(time * 2 + index + layerIndex) * 0.2;
                    glow.rotation.y += 0.003 * (layerIndex + 1);
                    glow.rotation.x += 0.002 * (layerIndex + 1);
                    
                    const scale = 1 + Math.sin(time * 3 + index + layerIndex) * 0.1;
                    glow.scale.setScalar(scale);
                });
            });

            // Animate cluster lines with subtle pulsing
            clusterLines.forEach((line, index) => {
                if (line.material) {
                    const baseOpacity = 0.3;
                    line.material.opacity = baseOpacity + Math.sin(time * 0.5 + index * 0.1) * 0.15;
                }
            });

            renderer.render(scene, camera);
        }

        // Start the application
        init();
    </script>
</body>
</html>