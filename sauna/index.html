<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sauna Structure Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --wood-dark: #5D4037;
            --wood-medium: #8D6E63;
            --wood-light: #BCAAA4;
            --cream: #FFF8F0;
            --charcoal: #2C2416;
            --amber: #D4A574;
            --amber-glow: #E8C9A0;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--cream);
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            opacity: 0.03;
            pointer-events: none;
            z-index: 1000;
        }

        .container {
            display: grid;
            grid-template-columns: minmax(320px, 420px) 1fr;
            height: 100vh;
            overflow: hidden;
        }

        .control-panel {
            background: linear-gradient(180deg, var(--charcoal) 0%, #1a1610 100%);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            height: 100vh;
        }

        .control-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--amber), var(--amber-glow), var(--amber));
            z-index: 10;
        }

        .panel-header {
            padding: 24px 20px 16px;
            flex-shrink: 0;
            border-bottom: 1px solid rgba(212, 165, 116, 0.1);
        }

        .logo {
            font-family: 'Instrument Serif', serif;
            font-size: clamp(22px, 3vw, 28px);
            color: var(--cream);
            margin-bottom: 4px;
            letter-spacing: -0.5px;
        }

        .logo span {
            color: var(--amber);
            font-style: italic;
        }

        .subtitle {
            color: var(--wood-light);
            font-size: 10px;
            letter-spacing: 2px;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .live-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(212, 165, 116, 0.2);
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 9px;
            color: var(--amber);
        }

        .live-dot {
            width: 6px;
            height: 6px;
            background: #4ade80;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 16px 20px;
            scrollbar-width: thin;
            scrollbar-color: var(--amber) transparent;
        }

        .panel-content::-webkit-scrollbar {
            width: 6px;
        }

        .panel-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .panel-content::-webkit-scrollbar-thumb {
            background: var(--amber);
            border-radius: 3px;
        }

        .panel-content::-webkit-scrollbar-thumb:hover {
            background: var(--amber-glow);
        }

        .panel-footer {
            flex-shrink: 0;
            padding: 16px 20px;
            border-top: 1px solid rgba(212, 165, 116, 0.1);
            background: rgba(0, 0, 0, 0.2);
        }

        .section {
            margin-bottom: 16px;
        }

        .section-title {
            color: var(--amber);
            font-size: 10px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            margin-bottom: 10px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title::before {
            content: '';
            width: 12px;
            height: 2px;
            background: var(--amber);
            flex-shrink: 0;
        }

        .input-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 8px;
        }

        .input-row.two-col {
            grid-template-columns: repeat(2, 1fr);
        }

        .input-group {
            margin-bottom: 10px;
        }

        .input-label {
            color: var(--wood-light);
            font-size: 9px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            margin-bottom: 5px;
            display: block;
        }

        .dimension-input {
            width: 100%;
            background: rgba(255, 248, 240, 0.05);
            border: 1px solid rgba(212, 165, 116, 0.2);
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 14px;
            font-family: 'DM Sans', sans-serif;
            font-weight: 500;
            color: var(--cream);
            transition: all 0.3s ease;
        }

        .dimension-input:focus {
            outline: none;
            border-color: var(--amber);
            background: rgba(255, 248, 240, 0.08);
        }

        .select-input {
            width: 100%;
            background: rgba(255, 248, 240, 0.05);
            border: 1px solid rgba(212, 165, 116, 0.2);
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 13px;
            font-family: 'DM Sans', sans-serif;
            color: var(--cream);
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23D4A574' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
        }

        .select-input:focus {
            outline: none;
            border-color: var(--amber);
        }

        .select-input option {
            background: var(--charcoal);
            color: var(--cream);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
        }

        .checkbox-input {
            width: 16px;
            height: 16px;
            accent-color: var(--amber);
            cursor: pointer;
            flex-shrink: 0;
        }

        .checkbox-label {
            color: var(--cream);
            font-size: 12px;
            cursor: pointer;
        }

        .window-config, .double-wall-config {
            background: rgba(255, 248, 240, 0.03);
            border-radius: 6px;
            padding: 10px;
            margin-top: 6px;
            margin-bottom: 8px;
            display: none;
        }

        .window-config.active, .double-wall-config.active {
            display: block;
        }

        .window-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 6px;
        }

        .window-row:last-child {
            margin-bottom: 0;
        }

        .mini-input {
            width: 100%;
            background: rgba(255, 248, 240, 0.05);
            border: 1px solid rgba(212, 165, 116, 0.15);
            border-radius: 4px;
            padding: 5px 7px;
            font-size: 12px;
            font-family: 'DM Sans', sans-serif;
            color: var(--cream);
        }

        .mini-input:focus {
            outline: none;
            border-color: var(--amber);
        }

        .mini-label {
            color: var(--wood-light);
            font-size: 8px;
            text-transform: uppercase;
            margin-bottom: 3px;
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .stat-item {
            background: rgba(255, 248, 240, 0.03);
            padding: 10px;
            border-radius: 6px;
        }

        .stat-label {
            color: var(--wood-light);
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            color: var(--cream);
            font-size: 16px;
            font-weight: 600;
            margin-top: 2px;
        }

        .stat-item.highlight {
            grid-column: 1 / -1;
            background: rgba(212, 165, 116, 0.1);
        }

        .stat-item.highlight .stat-value {
            color: var(--amber);
            font-size: 24px;
        }

        .collapsible {
            background: rgba(255, 248, 240, 0.03);
            border-radius: 8px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .collapsible-header {
            padding: 10px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background 0.2s;
            user-select: none;
        }

        .collapsible-header:hover {
            background: rgba(255, 248, 240, 0.03);
        }

        .collapsible-title {
            color: var(--cream);
            font-size: 12px;
            font-weight: 500;
        }

        .collapsible-icon {
            color: var(--amber);
            transition: transform 0.3s;
            font-size: 10px;
        }

        .collapsible.open .collapsible-icon {
            transform: rotate(180deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible.open .collapsible-content {
            max-height: 1000px;
        }

        .collapsible-inner {
            padding: 0 12px 12px;
        }

        .viewer-section {
            position: relative;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        .viewer-header {
            padding: 16px 20px;
            background: white;
            border-bottom: 1px solid rgba(93, 64, 55, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            flex-wrap: wrap;
            gap: 10px;
        }

        .viewer-title {
            font-family: 'Instrument Serif', serif;
            font-size: 18px;
            color: var(--charcoal);
        }

        .view-controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .view-btn {
            background: var(--cream);
            border: 1px solid rgba(93, 64, 55, 0.15);
            border-radius: 5px;
            padding: 6px 12px;
            font-family: 'DM Sans', sans-serif;
            font-size: 10px;
            font-weight: 500;
            color: var(--wood-dark);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .view-btn:hover, .view-btn.active {
            background: var(--wood-dark);
            color: var(--cream);
            border-color: var(--wood-dark);
        }

        #canvas-container {
            flex: 1;
            position: relative;
            background: linear-gradient(180deg, #F5EDE4 0%, #EDE5DC 100%);
            min-height: 0;
        }

        .instructions {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(44, 36, 22, 0.9);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 20px;
            color: var(--cream);
            font-size: 10px;
            display: flex;
            gap: 12px;
            white-space: nowrap;
        }

        .instructions span {
            opacity: 0.6;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 248, 240, 0.1);
            outline: none;
            margin: 8px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--amber);
            cursor: pointer;
            transition: background 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--amber-glow);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--amber);
            cursor: pointer;
            border: none;
        }

        .range-labels {
            display: flex;
            justify-content: space-between;
            color: var(--wood-light);
            font-size: 9px;
            margin-top: 2px;
        }

        .info-text {
            color: var(--wood-light);
            font-size: 10px;
            font-style: italic;
            margin-top: 8px;
            padding: 8px;
            background: rgba(212, 165, 116, 0.1);
            border-radius: 4px;
            line-height: 1.4;
        }

        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }

            .control-panel {
                height: auto;
                max-height: 50vh;
            }

            .viewer-section {
                height: 50vh;
            }

            .instructions {
                display: none;
            }
        }

        @media (max-width: 500px) {
            .input-row {
                grid-template-columns: repeat(2, 1fr);
            }

            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .view-controls {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="control-panel">
            <div class="panel-header">
                <h1 class="logo">Sauna <span>Builder</span></h1>
                <p class="subtitle">
                    3D Structure Generator
                    <span class="live-indicator">
                        <span class="live-dot"></span>
                        LIVE
                    </span>
                </p>
            </div>

            <div class="panel-content">
                <div class="section">
                    <div class="section-title">Sauna Dimensions (meters)</div>
                    <div class="input-row">
                        <div class="input-group">
                            <label class="input-label">Width (X)</label>
                            <input type="number" id="width" class="dimension-input" value="2.5" step="0.1" min="1">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Length (Z)</label>
                            <input type="number" id="length" class="dimension-input" value="3" step="0.1" min="1">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Height (Y)</label>
                            <input type="number" id="height" class="dimension-input" value="2.2" step="0.1" min="1.5">
                        </div>
                    </div>
                </div>

                <!-- Double Wall / Insulation Section -->
                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <span class="collapsible-title">üß± Double Wall & Insulation</span>
                        <span class="collapsible-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-inner">
                            <div class="checkbox-group">
                                <input type="checkbox" id="doubleWall" class="checkbox-input" onchange="toggleDoubleWallConfig()">
                                <label for="doubleWall" class="checkbox-label">Enable Double Wall Construction</label>
                            </div>
                            <div id="doubleWallConfig" class="double-wall-config">
                                <div class="window-row">
                                    <div>
                                        <span class="mini-label">Wall Gap (cm)</span>
                                        <input type="number" id="wallGap" class="mini-input" value="10" step="1" min="5" max="20">
                                    </div>
                                    <div>
                                        <span class="mini-label">Insulation Type</span>
                                        <select id="insulationType" class="mini-input" style="padding: 6px 7px;">
                                            <option value="rockwool">Rock Wool</option>
                                            <option value="fiberglass">Fiberglass</option>
                                            <option value="foam">Spray Foam</option>
                                            <option value="none">None (Air Gap)</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="checkbox-group">
                                    <input type="checkbox" id="showInsulation" class="checkbox-input" checked>
                                    <label for="showInsulation" class="checkbox-label">Show insulation in 3D view</label>
                                </div>
                                <div class="info-text">
                                    üí° Double walls create a cavity for insulation, improving heat retention. The outer wall faces outside, inner wall faces the sauna interior.
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="collapsible open">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <span class="collapsible-title">üè† Roof Style</span>
                        <span class="collapsible-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-inner">
                            <div class="input-group">
                                <label class="input-label">Roof Type</label>
                                <select id="roofType" class="select-input">
                                    <option value="flat">Flat Roof</option>
                                    <option value="gable">Gable Roof (A-frame)</option>
                                    <option value="shed">Shed Roof (Slanted)</option>
                                    <option value="hip">Hip Roof</option>
                                </select>
                            </div>
                            <div class="input-row two-col">
                                <div class="input-group">
                                    <label class="input-label">Roof Height (m)</label>
                                    <input type="number" id="roofHeight" class="dimension-input" value="0.6" step="0.1" min="0.2">
                                </div>
                                <div class="input-group">
                                    <label class="input-label">Overhang (m)</label>
                                    <input type="number" id="roofOverhang" class="dimension-input" value="0.15" step="0.05" min="0">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="collapsible open">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <span class="collapsible-title">üö™ Door Configuration</span>
                        <span class="collapsible-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-inner">
                            <div class="input-row two-col">
                                <div class="input-group">
                                    <label class="input-label">Width (m)</label>
                                    <input type="number" id="doorWidth" class="dimension-input" value="0.8" step="0.05" min="0.6">
                                </div>
                                <div class="input-group">
                                    <label class="input-label">Height (m)</label>
                                    <input type="number" id="doorHeight" class="dimension-input" value="1.9" step="0.05" min="1.5">
                                </div>
                            </div>
                            <div class="input-group">
                                <label class="input-label">Door Wall</label>
                                <select id="doorWall" class="select-input">
                                    <option value="front">Front Wall</option>
                                    <option value="back">Back Wall</option>
                                    <option value="left">Left Wall</option>
                                    <option value="right">Right Wall</option>
                                </select>
                            </div>
                            <div class="input-group">
                                <label class="input-label">Position</label>
                                <input type="range" id="doorPosition" min="10" max="90" value="50">
                                <div class="range-labels">
                                    <span>Left</span>
                                    <span id="doorPosValue">Center</span>
                                    <span>Right</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <span class="collapsible-title">ü™ü Windows</span>
                        <span class="collapsible-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-inner">
                            <div class="checkbox-group">
                                <input type="checkbox" id="windowFront" class="checkbox-input" onchange="toggleWindowConfig('Front')">
                                <label for="windowFront" class="checkbox-label">Front Wall Window</label>
                            </div>
                            <div id="windowFrontConfig" class="window-config">
                                <div class="window-row">
                                    <div><span class="mini-label">Width (m)</span><input type="number" id="windowFrontWidth" class="mini-input" value="0.6" step="0.1"></div>
                                    <div><span class="mini-label">Height (m)</span><input type="number" id="windowFrontHeight" class="mini-input" value="0.5" step="0.1"></div>
                                </div>
                                <div class="window-row">
                                    <div><span class="mini-label">From Floor (m)</span><input type="number" id="windowFrontY" class="mini-input" value="1.2" step="0.1"></div>
                                    <div><span class="mini-label">Position (%)</span><input type="number" id="windowFrontX" class="mini-input" value="50" min="10" max="90"></div>
                                </div>
                            </div>

                            <div class="checkbox-group">
                                <input type="checkbox" id="windowBack" class="checkbox-input" onchange="toggleWindowConfig('Back')">
                                <label for="windowBack" class="checkbox-label">Back Wall Window</label>
                            </div>
                            <div id="windowBackConfig" class="window-config">
                                <div class="window-row">
                                    <div><span class="mini-label">Width (m)</span><input type="number" id="windowBackWidth" class="mini-input" value="0.6" step="0.1"></div>
                                    <div><span class="mini-label">Height (m)</span><input type="number" id="windowBackHeight" class="mini-input" value="0.5" step="0.1"></div>
                                </div>
                                <div class="window-row">
                                    <div><span class="mini-label">From Floor (m)</span><input type="number" id="windowBackY" class="mini-input" value="1.2" step="0.1"></div>
                                    <div><span class="mini-label">Position (%)</span><input type="number" id="windowBackX" class="mini-input" value="50" min="10" max="90"></div>
                                </div>
                            </div>

                            <div class="checkbox-group">
                                <input type="checkbox" id="windowLeft" class="checkbox-input" onchange="toggleWindowConfig('Left')">
                                <label for="windowLeft" class="checkbox-label">Left Wall Window</label>
                            </div>
                            <div id="windowLeftConfig" class="window-config">
                                <div class="window-row">
                                    <div><span class="mini-label">Width (m)</span><input type="number" id="windowLeftWidth" class="mini-input" value="0.6" step="0.1"></div>
                                    <div><span class="mini-label">Height (m)</span><input type="number" id="windowLeftHeight" class="mini-input" value="0.5" step="0.1"></div>
                                </div>
                                <div class="window-row">
                                    <div><span class="mini-label">From Floor (m)</span><input type="number" id="windowLeftY" class="mini-input" value="1.2" step="0.1"></div>
                                    <div><span class="mini-label">Position (%)</span><input type="number" id="windowLeftX" class="mini-input" value="50" min="10" max="90"></div>
                                </div>
                            </div>

                            <div class="checkbox-group">
                                <input type="checkbox" id="windowRight" class="checkbox-input" onchange="toggleWindowConfig('Right')">
                                <label for="windowRight" class="checkbox-label">Right Wall Window</label>
                            </div>
                            <div id="windowRightConfig" class="window-config">
                                <div class="window-row">
                                    <div><span class="mini-label">Width (m)</span><input type="number" id="windowRightWidth" class="mini-input" value="0.6" step="0.1"></div>
                                    <div><span class="mini-label">Height (m)</span><input type="number" id="windowRightHeight" class="mini-input" value="0.5" step="0.1"></div>
                                </div>
                                <div class="window-row">
                                    <div><span class="mini-label">From Floor (m)</span><input type="number" id="windowRightY" class="mini-input" value="1.2" step="0.1"></div>
                                    <div><span class="mini-label">Position (%)</span><input type="number" id="windowRightX" class="mini-input" value="50" min="10" max="90"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleCollapsible(this)">
                        <span class="collapsible-title">ü™µ Plank Dimensions</span>
                        <span class="collapsible-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-inner">
                            <div class="input-row">
                                <div class="input-group">
                                    <label class="input-label">Width (cm)</label>
                                    <input type="number" id="plankWidth" class="dimension-input" value="10" step="1" min="5">
                                </div>
                                <div class="input-group">
                                    <label class="input-label">Thick (cm)</label>
                                    <input type="number" id="plankThickness" class="dimension-input" value="2" step="0.5" min="1">
                                </div>
                                <div class="input-group">
                                    <label class="input-label">Length (cm)</label>
                                    <input type="number" id="plankLength" class="dimension-input" value="250" step="10" min="100">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel-footer">
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-label">Outer Wall</div>
                        <div class="stat-value" id="wallPlanks">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Inner Wall</div>
                        <div class="stat-value" id="innerWallPlanks">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Roof</div>
                        <div class="stat-value" id="roofPlanks">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Floor</div>
                        <div class="stat-value" id="floorPlanks">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Gable</div>
                        <div class="stat-value" id="gablePlanks">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Insulation</div>
                        <div class="stat-value" id="insulationPanels">0</div>
                    </div>
                    <div class="stat-item highlight">
                        <div class="stat-label">Total Planks</div>
                        <div class="stat-value" id="totalPlanks">0</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="viewer-section">
            <div class="viewer-header">
                <h2 class="viewer-title">3D Preview</h2>
                <div class="view-controls">
                    <button class="view-btn active" onclick="setView('perspective')">Perspective</button>
                    <button class="view-btn" onclick="setView('front')">Front</button>
                    <button class="view-btn" onclick="setView('side')">Side</button>
                    <button class="view-btn" onclick="setView('top')">Top</button>
                    <button class="view-btn" onclick="resetCamera()">Reset</button>
                </div>
            </div>
            <div id="canvas-container"></div>
            <div class="instructions">
                <span>üñ±Ô∏è Drag: Orbit</span>
                <span>üñ±Ô∏è Scroll: Zoom</span>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer;
        let saunaGroup;
        
        let orbitRadius = 8;
        let orbitTheta = Math.PI / 4;
        let orbitPhi = Math.PI / 3;
        let orbitTarget = new THREE.Vector3(0, 1.1, 0);
        
        let isMouseDown = false;
        let prevMouseX = 0;
        let prevMouseY = 0;

        let wallPlanksCount = 0;
        let innerWallPlanksCount = 0;
        let roofPlanksCount = 0;
        let floorPlanksCount = 0;
        let gablePlanksCount = 0;
        let insulationPanelsCount = 0;

        let updateTimeout = null;

        // Insulation colors
        const insulationColors = {
            rockwool: 0xFFD700,
            fiberglass: 0xFFB6C1,
            foam: 0xFFF8DC,
            none: null
        };

        function init() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xF5EDE4);

            camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
            updateCameraFromOrbit();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const fillLight = new THREE.DirectionalLight(0xD4A574, 0.3);
            fillLight.position.set(-5, 5, -5);
            scene.add(fillLight);

            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xEDE5DC, roughness: 0.9 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01;
            ground.receiveShadow = true;
            scene.add(ground);

            const gridHelper = new THREE.GridHelper(10, 20, 0xBCAA99, 0xDDD5CC);
            scene.add(gridHelper);

            saunaGroup = new THREE.Group();
            scene.add(saunaGroup);

            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
            renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd);

            window.addEventListener('resize', onResize);

            setupRealTimeUpdates();

            generateSauna();
            animate();
        }

        function updateCameraFromOrbit() {
            const x = orbitRadius * Math.sin(orbitPhi) * Math.sin(orbitTheta);
            const y = orbitRadius * Math.cos(orbitPhi);
            const z = orbitRadius * Math.sin(orbitPhi) * Math.cos(orbitTheta);
            
            camera.position.set(
                orbitTarget.x + x,
                orbitTarget.y + y,
                orbitTarget.z + z
            );
            camera.lookAt(orbitTarget);
        }

        function onMouseDown(e) {
            isMouseDown = true;
            prevMouseX = e.clientX;
            prevMouseY = e.clientY;
            renderer.domElement.style.cursor = 'grabbing';
        }

        function onMouseMove(e) {
            if (!isMouseDown) return;
            
            const deltaX = e.clientX - prevMouseX;
            const deltaY = e.clientY - prevMouseY;
            
            orbitTheta -= deltaX * 0.01;
            orbitPhi -= deltaY * 0.01;
            orbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, orbitPhi));
            
            updateCameraFromOrbit();
            
            prevMouseX = e.clientX;
            prevMouseY = e.clientY;
        }

        function onMouseUp() {
            isMouseDown = false;
            renderer.domElement.style.cursor = 'grab';
        }

        function onWheel(e) {
            e.preventDefault();
            orbitRadius += e.deltaY * 0.01;
            orbitRadius = Math.max(2, Math.min(25, orbitRadius));
            updateCameraFromOrbit();
        }

        let lastTouchDistance = 0;
        let lastTouchX = 0;
        let lastTouchY = 0;

        function onTouchStart(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                lastTouchDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
        }

        function onTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 1) {
                const deltaX = e.touches[0].clientX - lastTouchX;
                const deltaY = e.touches[0].clientY - lastTouchY;
                
                orbitTheta -= deltaX * 0.01;
                orbitPhi -= deltaY * 0.01;
                orbitPhi = Math.max(0.1, Math.min(Math.PI - 0.1, orbitPhi));
                
                updateCameraFromOrbit();
                
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                const distance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                const delta = lastTouchDistance - distance;
                
                orbitRadius += delta * 0.02;
                orbitRadius = Math.max(2, Math.min(25, orbitRadius));
                
                updateCameraFromOrbit();
                lastTouchDistance = distance;
            }
        }

        function onTouchEnd() {
            lastTouchDistance = 0;
        }

        function setupRealTimeUpdates() {
            const inputs = document.querySelectorAll('input, select');
            
            inputs.forEach(input => {
                if (input.type === 'range' || input.type === 'number') {
                    input.addEventListener('input', scheduleUpdate);
                }
                if (input.tagName === 'SELECT' || input.type === 'checkbox') {
                    input.addEventListener('change', scheduleUpdate);
                }
            });

            document.getElementById('doorPosition').addEventListener('input', function() {
                const val = this.value;
                document.getElementById('doorPosValue').textContent = val == 50 ? 'Center' : val + '%';
            });
        }

        function scheduleUpdate() {
            if (updateTimeout) {
                clearTimeout(updateTimeout);
            }
            updateTimeout = setTimeout(() => {
                generateSauna(true);
            }, 50);
        }

        function toggleCollapsible(header) {
            header.parentElement.classList.toggle('open');
        }

        function toggleWindowConfig(side) {
            const checkbox = document.getElementById('window' + side);
            const config = document.getElementById('window' + side + 'Config');
            config.classList.toggle('active', checkbox.checked);
            scheduleUpdate();
        }

        function toggleDoubleWallConfig() {
            const checkbox = document.getElementById('doubleWall');
            const config = document.getElementById('doubleWallConfig');
            config.classList.toggle('active', checkbox.checked);
            scheduleUpdate();
        }

        function onResize() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        function createWoodTexture(darker = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            const baseColor = darker ? '#9B7653' : '#C4956A';
            const midColor = darker ? '#B8956A' : '#D4A574';
            const gradient = ctx.createLinearGradient(0, 0, 256, 0);
            gradient.addColorStop(0, baseColor);
            gradient.addColorStop(0.3, midColor);
            gradient.addColorStop(0.5, baseColor);
            gradient.addColorStop(0.7, midColor);
            gradient.addColorStop(1, baseColor);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 64);

            ctx.strokeStyle = 'rgba(139, 90, 43, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 20; i++) {
                const y = Math.random() * 64;
                ctx.beginPath();
                ctx.moveTo(0, y);
                for (let x = 0; x < 256; x += 10) {
                    ctx.lineTo(x, y + Math.sin(x * 0.05) * 2 + Math.random() * 2);
                }
                ctx.stroke();
            }

            for (let i = 0; i < 2; i++) {
                const x = Math.random() * 200 + 28;
                const y = Math.random() * 40 + 12;
                const radius = Math.random() * 4 + 3;
                const knotGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                knotGradient.addColorStop(0, '#6B4423');
                knotGradient.addColorStop(0.5, '#8B5A2B');
                knotGradient.addColorStop(1, '#A0784C');
                ctx.fillStyle = knotGradient;
                ctx.beginPath();
                ctx.ellipse(x, y, radius, radius * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }

        function createPlank(width, height, depth, darker = false) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const texture = createWoodTexture(darker);
            texture.repeat.set(Math.max(width, depth) / 0.25, 1);

            const material = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.8,
                metalness: 0.0
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        function createInsulationPanel(width, height, depth, type) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const color = insulationColors[type] || 0xFFD700;
            
            const material = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.9,
                metalness: 0.0,
                transparent: true,
                opacity: 0.7
            });

            const mesh = new THREE.Mesh(geometry, material);
            return mesh;
        }

        function createGlassMaterial() {
            return new THREE.MeshPhysicalMaterial({
                color: 0x88ccff,
                metalness: 0,
                roughness: 0,
                transmission: 0.9,
                transparent: true,
                opacity: 0.3
            });
        }

        function generateSauna(keepCamera = false) {
            while (saunaGroup.children.length > 0) {
                const child = saunaGroup.children[0];
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (child.material.map) child.material.map.dispose();
                    child.material.dispose();
                }
                saunaGroup.remove(child);
            }

            wallPlanksCount = 0;
            innerWallPlanksCount = 0;
            roofPlanksCount = 0;
            floorPlanksCount = 0;
            gablePlanksCount = 0;
            insulationPanelsCount = 0;

            const saunaWidth = parseFloat(document.getElementById('width').value) || 2.5;
            const saunaLength = parseFloat(document.getElementById('length').value) || 3;
            const saunaHeight = parseFloat(document.getElementById('height').value) || 2.2;

            const plankWidth = (parseFloat(document.getElementById('plankWidth').value) || 10) / 100;
            const plankThickness = (parseFloat(document.getElementById('plankThickness').value) || 2) / 100;

            const doorWidth = parseFloat(document.getElementById('doorWidth').value) || 0.8;
            const doorHeight = parseFloat(document.getElementById('doorHeight').value) || 1.9;
            const doorWall = document.getElementById('doorWall').value;
            const doorPosition = (parseFloat(document.getElementById('doorPosition').value) || 50) / 100;

            const roofType = document.getElementById('roofType').value;
            const roofHeight = parseFloat(document.getElementById('roofHeight').value) || 0.6;
            const roofOverhang = parseFloat(document.getElementById('roofOverhang').value) || 0.15;

            // Double wall settings
            const doubleWallEnabled = document.getElementById('doubleWall').checked;
            const wallGap = doubleWallEnabled ? (parseFloat(document.getElementById('wallGap').value) || 10) / 100 : 0;
            const insulationType = document.getElementById('insulationType').value;
            const showInsulation = document.getElementById('showInsulation').checked;

            const gap = 0.002;

            const windows = {
                front: getWindowConfig('Front'),
                back: getWindowConfig('Back'),
                left: getWindowConfig('Left'),
                right: getWindowConfig('Right')
            };

            // Calculate total wall thickness for positioning
            const totalWallThickness = doubleWallEnabled ? (plankThickness * 2 + wallGap) : plankThickness;

            // Generate outer walls
            generateWall('front', saunaWidth, saunaHeight, saunaLength, plankWidth, plankThickness, gap, 
                        doorWall === 'front' ? { width: doorWidth, height: doorHeight, position: doorPosition } : null,
                        windows.front, false, 0);
            generateWall('back', saunaWidth, saunaHeight, saunaLength, plankWidth, plankThickness, gap,
                        doorWall === 'back' ? { width: doorWidth, height: doorHeight, position: doorPosition } : null,
                        windows.back, false, 0);
            generateWall('left', saunaLength, saunaHeight, saunaWidth, plankWidth, plankThickness, gap,
                        doorWall === 'left' ? { width: doorWidth, height: doorHeight, position: doorPosition } : null,
                        windows.left, false, 0);
            generateWall('right', saunaLength, saunaHeight, saunaWidth, plankWidth, plankThickness, gap,
                        doorWall === 'right' ? { width: doorWidth, height: doorHeight, position: doorPosition } : null,
                        windows.right, false, 0);

            // Generate inner walls if double wall is enabled
            if (doubleWallEnabled) {
                const innerOffset = plankThickness + wallGap;
                
                generateWall('front', saunaWidth - 2 * innerOffset, saunaHeight, saunaLength, plankWidth, plankThickness, gap, 
                            doorWall === 'front' ? { width: doorWidth, height: doorHeight, position: doorPosition } : null,
                            windows.front, true, innerOffset);
                generateWall('back', saunaWidth - 2 * innerOffset, saunaHeight, saunaLength, plankWidth, plankThickness, gap,
                            doorWall === 'back' ? { width: doorWidth, height: doorHeight, position: doorPosition } : null,
                            windows.back, true, innerOffset);
                generateWall('left', saunaLength - 2 * innerOffset, saunaHeight, saunaWidth, plankWidth, plankThickness, gap,
                            doorWall === 'left' ? { width: doorWidth, height: doorHeight, position: doorPosition } : null,
                            windows.left, true, innerOffset);
                generateWall('right', saunaLength - 2 * innerOffset, saunaHeight, saunaWidth, plankWidth, plankThickness, gap,
                            doorWall === 'right' ? { width: doorWidth, height: doorHeight, position: doorPosition } : null,
                            windows.right, true, innerOffset);

                // Generate insulation if enabled and visible
                if (showInsulation && insulationType !== 'none') {
                    generateInsulation(saunaWidth, saunaHeight, saunaLength, plankThickness, wallGap, insulationType,
                                      doorWall === 'front' ? { width: doorWidth, height: doorHeight, position: doorPosition } : null,
                                      doorWall === 'back' ? { width: doorWidth, height: doorHeight, position: doorPosition } : null,
                                      doorWall === 'left' ? { width: doorWidth, height: doorHeight, position: doorPosition } : null,
                                      doorWall === 'right' ? { width: doorWidth, height: doorHeight, position: doorPosition } : null,
                                      windows);
                }
            }

            generateFloor(saunaWidth, saunaLength, plankWidth, plankThickness, gap);
            generateRoof(roofType, saunaWidth, saunaLength, saunaHeight, roofHeight, roofOverhang, plankWidth, plankThickness, gap);

            // Corner posts
            const postSize = 0.05;
            const postMaterial = new THREE.MeshStandardMaterial({ color: 0x8B5A2B, roughness: 0.7 });
            const corners = [
                [-saunaWidth/2, saunaHeight/2, -saunaLength/2],
                [saunaWidth/2, saunaHeight/2, -saunaLength/2],
                [-saunaWidth/2, saunaHeight/2, saunaLength/2],
                [saunaWidth/2, saunaHeight/2, saunaLength/2]
            ];
            corners.forEach(pos => {
                const postGeometry = new THREE.BoxGeometry(postSize, saunaHeight, postSize);
                const post = new THREE.Mesh(postGeometry, postMaterial);
                post.position.set(...pos);
                post.castShadow = true;
                saunaGroup.add(post);
            });

            // Update stats
            document.getElementById('wallPlanks').textContent = wallPlanksCount;
            document.getElementById('innerWallPlanks').textContent = innerWallPlanksCount;
            document.getElementById('roofPlanks').textContent = roofPlanksCount;
            document.getElementById('floorPlanks').textContent = floorPlanksCount;
            document.getElementById('gablePlanks').textContent = gablePlanksCount;
            document.getElementById('insulationPanels').textContent = insulationPanelsCount;
            document.getElementById('totalPlanks').textContent = wallPlanksCount + innerWallPlanksCount + roofPlanksCount + floorPlanksCount + gablePlanksCount;

            orbitTarget.set(0, saunaHeight / 2, 0);
            
            if (!keepCamera) {
                orbitRadius = Math.max(saunaWidth, saunaLength, saunaHeight) * 2.5;
                orbitTheta = Math.PI / 4;
                orbitPhi = Math.PI / 3;
            }
            
            updateCameraFromOrbit();
        }

        function generateInsulation(width, height, length, plankThickness, wallGap, type, doorFront, doorBack, doorLeft, doorRight, windows) {
            const insulationThickness = wallGap - 0.01;
            const offset = plankThickness + wallGap / 2;

            // Front insulation
            if (!doorFront || doorFront.height < height) {
                const frontPanel = createInsulationPanel(width - plankThickness * 2, height, insulationThickness, type);
                frontPanel.position.set(0, height / 2, -length / 2 + offset);
                saunaGroup.add(frontPanel);
                insulationPanelsCount++;
            }

            // Back insulation
            if (!doorBack || doorBack.height < height) {
                const backPanel = createInsulationPanel(width - plankThickness * 2, height, insulationThickness, type);
                backPanel.position.set(0, height / 2, length / 2 - offset);
                saunaGroup.add(backPanel);
                insulationPanelsCount++;
            }

            // Left insulation
            if (!doorLeft || doorLeft.height < height) {
                const leftPanel = createInsulationPanel(insulationThickness, height, length - plankThickness * 2, type);
                leftPanel.position.set(-width / 2 + offset, height / 2, 0);
                saunaGroup.add(leftPanel);
                insulationPanelsCount++;
            }

            // Right insulation
            if (!doorRight || doorRight.height < height) {
                const rightPanel = createInsulationPanel(insulationThickness, height, length - plankThickness * 2, type);
                rightPanel.position.set(width / 2 - offset, height / 2, 0);
                saunaGroup.add(rightPanel);
                insulationPanelsCount++;
            }
        }

        function getWindowConfig(side) {
            const checkbox = document.getElementById('window' + side);
            if (!checkbox || !checkbox.checked) return null;
            return {
                width: parseFloat(document.getElementById('window' + side + 'Width').value) || 0.6,
                height: parseFloat(document.getElementById('window' + side + 'Height').value) || 0.5,
                y: parseFloat(document.getElementById('window' + side + 'Y').value) || 1.2,
                position: (parseFloat(document.getElementById('window' + side + 'X').value) || 50) / 100
            };
        }

        function generateWall(side, wallWidth, wallHeight, depth, plankWidth, plankThickness, gap, door, window, isInner, innerOffset) {
            const planksNeeded = Math.ceil(wallHeight / (plankWidth + gap));
            const offsetAmount = isInner ? innerOffset : 0;

            for (let i = 0; i < planksNeeded; i++) {
                const y = i * (plankWidth + gap) + plankWidth / 2;
                if (y > wallHeight) break;

                const plankBottom = y - plankWidth / 2;
                const plankTop = y + plankWidth / 2;

                let segments = [{ start: 0, end: wallWidth }];

                if (door) {
                    const doorCenter = wallWidth * door.position;
                    const doorLeft = doorCenter - door.width / 2;
                    const doorRight = doorCenter + door.width / 2;

                    if (plankTop <= door.height) {
                        segments = cutSegment(segments, doorLeft, doorRight);
                    }
                }

                if (window) {
                    const winCenter = wallWidth * window.position;
                    const winLeft = winCenter - window.width / 2;
                    const winRight = winCenter + window.width / 2;
                    const winBottom = window.y;
                    const winTop = window.y + window.height;

                    if (plankBottom < winTop && plankTop > winBottom) {
                        segments = cutSegment(segments, winLeft, winRight);
                    }
                }

                segments.forEach(seg => {
                    const segWidth = seg.end - seg.start;
                    if (segWidth < 0.05) return;

                    const plank = createPlank(segWidth, plankWidth, plankThickness, isInner);
                    const centerX = seg.start + segWidth / 2 - wallWidth / 2;

                    switch(side) {
                        case 'front':
                            plank.position.set(centerX, y, -depth/2 + offsetAmount);
                            break;
                        case 'back':
                            plank.position.set(-centerX, y, depth/2 - offsetAmount);
                            break;
                        case 'left':
                            plank.rotation.y = Math.PI / 2;
                            plank.position.set(-depth/2 + offsetAmount, y, -centerX);
                            break;
                        case 'right':
                            plank.rotation.y = Math.PI / 2;
                            plank.position.set(depth/2 - offsetAmount, y, centerX);
                            break;
                    }
                    saunaGroup.add(plank);
                    if (isInner) {
                        innerWallPlanksCount++;
                    } else {
                        wallPlanksCount++;
                    }
                });
            }

            // Only add window glass and frame to outer wall
            if (window && !isInner) {
                const glass = new THREE.Mesh(
                    new THREE.PlaneGeometry(window.width, window.height),
                    createGlassMaterial()
                );
                const winCenter = wallWidth * window.position - wallWidth / 2;
                const winY = window.y + window.height / 2;

                switch(side) {
                    case 'front':
                        glass.position.set(winCenter, winY, -depth/2 + 0.01);
                        break;
                    case 'back':
                        glass.position.set(-winCenter, winY, depth/2 - 0.01);
                        glass.rotation.y = Math.PI;
                        break;
                    case 'left':
                        glass.rotation.y = Math.PI / 2;
                        glass.position.set(-depth/2 + 0.01, winY, -winCenter);
                        break;
                    case 'right':
                        glass.rotation.y = -Math.PI / 2;
                        glass.position.set(depth/2 - 0.01, winY, winCenter);
                        break;
                }
                saunaGroup.add(glass);

                const frameMaterial = new THREE.MeshStandardMaterial({ color: 0x5D4037, roughness: 0.6 });
                const frameThickness = 0.03;
                const frameDepth = 0.04;

                const framePositions = [
                    { w: window.width + frameThickness*2, h: frameThickness, x: 0, y: window.height/2 + frameThickness/2 },
                    { w: window.width + frameThickness*2, h: frameThickness, x: 0, y: -window.height/2 - frameThickness/2 },
                    { w: frameThickness, h: window.height, x: -window.width/2 - frameThickness/2, y: 0 },
                    { w: frameThickness, h: window.height, x: window.width/2 + frameThickness/2, y: 0 }
                ];

                framePositions.forEach(fp => {
                    const frame = new THREE.Mesh(
                        new THREE.BoxGeometry(fp.w, fp.h, frameDepth),
                        frameMaterial
                    );
                    switch(side) {
                        case 'front':
                            frame.position.set(winCenter + fp.x, winY + fp.y, -depth/2);
                            break;
                        case 'back':
                            frame.position.set(-winCenter - fp.x, winY + fp.y, depth/2);
                            break;
                        case 'left':
                            frame.rotation.y = Math.PI / 2;
                            frame.position.set(-depth/2, winY + fp.y, -winCenter - fp.x);
                            break;
                        case 'right':
                            frame.rotation.y = Math.PI / 2;
                            frame.position.set(depth/2, winY + fp.y, winCenter + fp.x);
                            break;
                    }
                    frame.castShadow = true;
                    saunaGroup.add(frame);
                });
            }
        }

        function cutSegment(segments, cutStart, cutEnd) {
            const result = [];
            segments.forEach(seg => {
                if (cutEnd <= seg.start || cutStart >= seg.end) {
                    result.push(seg);
                } else {
                    if (cutStart > seg.start) {
                        result.push({ start: seg.start, end: cutStart });
                    }
                    if (cutEnd < seg.end) {
                        result.push({ start: cutEnd, end: seg.end });
                    }
                }
            });
            return result;
        }

        function generateFloor(width, length, plankWidth, plankThickness, gap) {
            const planksNeeded = Math.ceil(width / (plankWidth + gap));
            for (let i = 0; i < planksNeeded; i++) {
                const x = -width/2 + i * (plankWidth + gap) + plankWidth/2;
                if (x > width/2) break;

                const plank = createPlank(plankWidth, plankThickness, length);
                plank.position.set(x, plankThickness/2, 0);
                saunaGroup.add(plank);
                floorPlanksCount++;
            }
        }

        function generateRoof(type, width, length, height, roofHeight, overhang, plankWidth, plankThickness, gap) {
            switch(type) {
                case 'flat':
                    generateFlatRoof(width, length, height, overhang, plankWidth, plankThickness, gap);
                    break;
                case 'gable':
                    generateGableRoof(width, length, height, roofHeight, overhang, plankWidth, plankThickness, gap);
                    break;
                case 'shed':
                    generateShedRoof(width, length, height, roofHeight, overhang, plankWidth, plankThickness, gap);
                    break;
                case 'hip':
                    generateHipRoof(width, length, height, roofHeight, overhang, plankWidth, plankThickness, gap);
                    break;
            }
        }

        function generateFlatRoof(width, length, height, overhang, plankWidth, plankThickness, gap) {
            const roofWidth = width + overhang * 2;
            const roofLength = length + overhang * 2;
            const planksNeeded = Math.ceil(roofWidth / (plankWidth + gap));

            for (let i = 0; i < planksNeeded; i++) {
                const x = -roofWidth/2 + i * (plankWidth + gap) + plankWidth/2;
                if (x > roofWidth/2) break;

                const plank = createPlank(plankWidth, plankThickness, roofLength, true);
                plank.position.set(x, height + plankThickness/2, 0);
                saunaGroup.add(plank);
                roofPlanksCount++;
            }
        }

        function generateGableRoof(width, length, height, roofHeight, overhang, plankWidth, plankThickness, gap) {
            const roofLength = length + overhang * 2;
            const halfWidth = width / 2 + overhang;
            const slopeLength = Math.sqrt(halfWidth * halfWidth + roofHeight * roofHeight);
            const angle = Math.atan2(roofHeight, halfWidth);

            const leftPlanks = Math.ceil(slopeLength / (plankWidth + gap));
            for (let i = 0; i < leftPlanks; i++) {
                const dist = i * (plankWidth + gap) + plankWidth/2;
                if (dist > slopeLength) break;

                const plank = createPlank(plankWidth, plankThickness, roofLength, true);
                plank.rotation.z = angle;
                const x = -halfWidth + dist * Math.cos(angle) + (plankWidth/2) * Math.sin(angle);
                const y = height + dist * Math.sin(angle) + (plankThickness/2) * Math.cos(angle);
                plank.position.set(x, y, 0);
                saunaGroup.add(plank);
                roofPlanksCount++;
            }

            for (let i = 0; i < leftPlanks; i++) {
                const dist = i * (plankWidth + gap) + plankWidth/2;
                if (dist > slopeLength) break;

                const plank = createPlank(plankWidth, plankThickness, roofLength, true);
                plank.rotation.z = -angle;
                const x = halfWidth - dist * Math.cos(angle) - (plankWidth/2) * Math.sin(angle);
                const y = height + dist * Math.sin(angle) + (plankThickness/2) * Math.cos(angle);
                plank.position.set(x, y, 0);
                saunaGroup.add(plank);
                roofPlanksCount++;
            }

            generateGableEnd(width, height, roofHeight, plankWidth, plankThickness, gap, -length/2);
            generateGableEnd(width, height, roofHeight, plankWidth, plankThickness, gap, length/2);
        }

        function generateGableEnd(width, height, roofHeight, plankWidth, plankThickness, gap, zPos) {
            const planksNeeded = Math.ceil(roofHeight / (plankWidth + gap));

            for (let i = 0; i < planksNeeded; i++) {
                const y = height + i * (plankWidth + gap) + plankWidth/2;
                const progress = (i * (plankWidth + gap)) / roofHeight;
                const currentWidth = width * (1 - progress);

                if (currentWidth < 0.1) break;

                const plank = createPlank(currentWidth, plankWidth, plankThickness);
                plank.position.set(0, y, zPos);
                saunaGroup.add(plank);
                gablePlanksCount++;
            }
        }

        function generateShedRoof(width, length, height, roofHeight, overhang, plankWidth, plankThickness, gap) {
            const roofWidth = width + overhang * 2;
            const roofLength = length + overhang * 2;
            const slopeLength = Math.sqrt(roofWidth * roofWidth + roofHeight * roofHeight);
            const angle = Math.atan2(roofHeight, roofWidth);

            const planksNeeded = Math.ceil(slopeLength / (plankWidth + gap));

            // Main sloped roof
            for (let i = 0; i < planksNeeded; i++) {
                const dist = i * (plankWidth + gap) + plankWidth/2;
                if (dist > slopeLength) break;

                const plank = createPlank(plankWidth, plankThickness, roofLength, true);
                plank.rotation.z = angle;
                const x = -roofWidth/2 + dist * Math.cos(angle) + (plankWidth/2) * Math.sin(angle);
                const y = height + dist * Math.sin(angle) + (plankThickness/2) * Math.cos(angle);
                plank.position.set(x, y, 0);
                saunaGroup.add(plank);
                roofPlanksCount++;
            }

            // Front and back triangular gable fills
            generateShedTriangle(width, length, height, roofHeight, plankWidth, plankThickness, gap, -length/2);
            generateShedTriangle(width, length, height, roofHeight, plankWidth, plankThickness, gap, length/2);

            // HIGH SIDE WALL - Fill the right wall from base height to roof height
            generateShedHighSideWall(width, length, height, roofHeight, plankWidth, plankThickness, gap);
        }

        function generateShedTriangle(width, length, height, roofHeight, plankWidth, plankThickness, gap, zPos) {
            const planksNeeded = Math.ceil(roofHeight / (plankWidth + gap));
            
            for (let i = 0; i < planksNeeded; i++) {
                const y = height + i * (plankWidth + gap) + plankWidth/2;
                if (y > height + roofHeight) break;
                
                // Calculate the roof line at this height
                const heightAboveBase = y - height - plankWidth/2;
                const roofX = -width/2 + (heightAboveBase / roofHeight) * width;
                
                // Plank goes from roofX to right side
                const plankStartX = roofX;
                const plankEndX = width/2;
                const plankLength = plankEndX - plankStartX;
                
                if (plankLength < 0.05) continue;
                
                const plank = createPlank(plankLength, plankWidth, plankThickness);
                const xPos = plankStartX + plankLength/2;
                plank.position.set(xPos, y, zPos);
                saunaGroup.add(plank);
                gablePlanksCount++;
            }
        }

        function generateShedHighSideWall(width, length, height, roofHeight, plankWidth, plankThickness, gap) {
            // Fill the right (high) side wall above the base height
            const planksNeeded = Math.ceil(roofHeight / (plankWidth + gap));
            
            for (let i = 0; i < planksNeeded; i++) {
                const y = height + i * (plankWidth + gap) + plankWidth/2;
                if (y > height + roofHeight) break;
                
                const plank = createPlank(plankThickness, plankWidth, length);
                plank.position.set(width/2, y, 0);
                saunaGroup.add(plank);
                gablePlanksCount++;
            }
        }

        function generateHipRoof(width, length, height, roofHeight, overhang, plankWidth, plankThickness, gap) {
            const roofWidth = width + overhang * 2;
            const roofLength = length + overhang * 2;
            
            const halfWidth = roofWidth / 2;
            const halfLength = roofLength / 2;
            const ridgeLength = Math.max(0, roofLength - roofWidth);
            
            const slopeLengthSide = Math.sqrt(halfWidth * halfWidth + roofHeight * roofHeight);
            const angleSide = Math.atan2(roofHeight, halfWidth);

            const slopeLengthEnd = Math.sqrt(halfWidth * halfWidth + roofHeight * roofHeight);
            const angleEnd = Math.atan2(roofHeight, halfWidth);

            const sidePlanks = Math.ceil(slopeLengthSide / (plankWidth + gap));
            
            for (let i = 0; i < sidePlanks; i++) {
                const dist = i * (plankWidth + gap) + plankWidth/2;
                if (dist > slopeLengthSide) break;

                const progress = dist / slopeLengthSide;
                const currentLength = roofLength - (roofLength - ridgeLength) * progress;
                if (currentLength < 0.1) break;

                const plank = createPlank(plankWidth, plankThickness, currentLength, true);
                plank.rotation.z = angleSide;
                const x = -halfWidth + dist * Math.cos(angleSide) + (plankWidth/2) * Math.sin(angleSide);
                const y = height + dist * Math.sin(angleSide) + (plankThickness/2) * Math.cos(angleSide);
                plank.position.set(x, y, 0);
                saunaGroup.add(plank);
                roofPlanksCount++;
            }

            for (let i = 0; i < sidePlanks; i++) {
                const dist = i * (plankWidth + gap) + plankWidth/2;
                if (dist > slopeLengthSide) break;

                const progress = dist / slopeLengthSide;
                const currentLength = roofLength - (roofLength - ridgeLength) * progress;
                if (currentLength < 0.1) break;

                const plank = createPlank(plankWidth, plankThickness, currentLength, true);
                plank.rotation.z = -angleSide;
                const x = halfWidth - dist * Math.cos(angleSide) - (plankWidth/2) * Math.sin(angleSide);
                const y = height + dist * Math.sin(angleSide) + (plankThickness/2) * Math.cos(angleSide);
                plank.position.set(x, y, 0);
                saunaGroup.add(plank);
                roofPlanksCount++;
            }

            const frontPlanks = Math.ceil(slopeLengthEnd / (plankWidth + gap));
            for (let i = 0; i < frontPlanks; i++) {
                const dist = i * (plankWidth + gap) + plankWidth/2;
                if (dist > slopeLengthEnd) break;

                const progress = dist / slopeLengthEnd;
                const currentWidth = roofWidth * (1 - progress);
                if (currentWidth < 0.1) break;

                const plank = createPlank(currentWidth, plankThickness, plankWidth, true);
                plank.rotation.x = -angleEnd;
                const z = -halfLength + dist * Math.cos(angleEnd) + (plankWidth/2) * Math.sin(angleEnd);
                const y = height + dist * Math.sin(angleEnd) + (plankThickness/2) * Math.cos(angleEnd);
                plank.position.set(0, y, z);
                saunaGroup.add(plank);
                roofPlanksCount++;
            }

            for (let i = 0; i < frontPlanks; i++) {
                const dist = i * (plankWidth + gap) + plankWidth/2;
                if (dist > slopeLengthEnd) break;

                const progress = dist / slopeLengthEnd;
                const currentWidth = roofWidth * (1 - progress);
                if (currentWidth < 0.1) break;

                const plank = createPlank(currentWidth, plankThickness, plankWidth, true);
                plank.rotation.x = angleEnd;
                const z = halfLength - dist * Math.cos(angleEnd) - (plankWidth/2) * Math.sin(angleEnd);
                const y = height + dist * Math.sin(angleEnd) + (plankThickness/2) * Math.cos(angleEnd);
                plank.position.set(0, y, z);
                saunaGroup.add(plank);
                roofPlanksCount++;
            }
        }

        function setView(view) {
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            const saunaHeight = parseFloat(document.getElementById('height').value) || 2.2;
            const saunaWidth = parseFloat(document.getElementById('width').value) || 2.5;
            const saunaLength = parseFloat(document.getElementById('length').value) || 3;
            const maxDim = Math.max(saunaWidth, saunaLength, saunaHeight);

            orbitTarget.set(0, saunaHeight / 2, 0);

            switch(view) {
                case 'perspective':
                    orbitTheta = Math.PI / 4;
                    orbitPhi = Math.PI / 3;
                    orbitRadius = maxDim * 2.5;
                    break;
                case 'front':
                    orbitTheta = 0;
                    orbitPhi = Math.PI / 2;
                    orbitRadius = maxDim * 2;
                    break;
                case 'side':
                    orbitTheta = Math.PI / 2;
                    orbitPhi = Math.PI / 2;
                    orbitRadius = maxDim * 2;
                    break;
                case 'top':
                    orbitTheta = 0;
                    orbitPhi = 0.01;
                    orbitRadius = maxDim * 2;
                    break;
            }

            updateCameraFromOrbit();
        }

        function resetCamera() {
            const saunaHeight = parseFloat(document.getElementById('height').value) || 2.2;
            const saunaWidth = parseFloat(document.getElementById('width').value) || 2.5;
            const saunaLength = parseFloat(document.getElementById('length').value) || 3;
            const maxDim = Math.max(saunaWidth, saunaLength, saunaHeight);

            orbitTarget.set(0, saunaHeight / 2, 0);
            orbitTheta = Math.PI / 4;
            orbitPhi = Math.PI / 3;
            orbitRadius = maxDim * 2.5;
            
            updateCameraFromOrbit();
            
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.view-btn').classList.add('active');
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
