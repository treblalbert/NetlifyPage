<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="cursor-trail.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCII Dwarf Simulation - Albert Adroer Prats</title>
    <link rel="stylesheet" href="../cursor-trail.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            min-height: 100vh;
            overflow-x: auto;
            position: relative;
        }

        .background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.25) 0%, 
                rgba(255, 255, 255, 0.1) 50%,
                rgba(255, 255, 255, 0.2) 100%);
            backdrop-filter: blur(15px) saturate(160%);
            -webkit-backdrop-filter: blur(15px) saturate(160%);
            color: white;
            padding: 12px 20px;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 600;
            z-index: 1000;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid transparent;
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.15),
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.1) inset,
                0 0 0 1px rgba(255, 255, 255, 0.3);
        }

        .back-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, 
                rgba(255, 255, 255, 0.3) 0%,
                transparent 100%);
            border-radius: 25px 25px 0 0;
            pointer-events: none;
        }

        .source-buttons {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .source-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(20px);
            color: white;
            padding: 12px 16px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            font-size: 14px;
        }

        .back-button:hover, .source-btn:hover {
            transform: translateY(-3px) scale(1.02);
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.35) 0%, 
                rgba(255, 255, 255, 0.15) 50%,
                rgba(255, 255, 255, 0.25) 100%);
            backdrop-filter: blur(20px) saturate(200%);
            -webkit-backdrop-filter: blur(20px) saturate(200%);
            box-shadow: 
                0 12px 30px rgba(0, 0, 0, 0.25),
                0 1px 0 rgba(255, 255, 255, 0.8) inset,
                0 -1px 0 rgba(0, 0, 0, 0.15) inset,
                0 0 0 1px rgba(255, 255, 255, 0.5),
                0 0 15px rgba(255, 255, 255, 0.2);
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            padding: 80px 20px 20px;
            max-width: 1800px;
            margin: 0 auto;
            position: relative;
            z-index: 10;
            min-height: calc(100vh - 100px);
        }

        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .glass-panel {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.22) 0%, 
                rgba(255, 255, 255, 0.08) 25%,
                rgba(255, 255, 255, 0.04) 50%,
                rgba(255, 255, 255, 0.08) 75%,
                rgba(255, 255, 255, 0.22) 100%);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border-radius: 25px;
            padding: 25px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.2),
                0 1px 0 rgba(255, 255, 255, 0.8) inset,
                0 -1px 0 rgba(0, 0, 0, 0.2) inset,
                0 0 0 1px rgba(255, 255, 255, 0.3);
            border: 1px solid transparent;
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .glass-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 40%;
            background: linear-gradient(180deg, 
                rgba(255, 255, 255, 0.25) 0%,
                rgba(255, 255, 255, 0.08) 60%,
                transparent 100%);
            border-radius: 25px 25px 0 0;
            pointer-events: none;
        }

        .glass-panel::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            background: linear-gradient(145deg, 
                transparent 0%,
                rgba(255, 255, 255, 0.08) 30%,
                transparent 70%,
                rgba(255, 255, 255, 0.04) 100%);
            border-radius: 23px;
            pointer-events: none;
        }

        .glass-panel:hover {
            transform: translateY(-3px) scale(1.01);
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.32) 0%, 
                rgba(255, 255, 255, 0.12) 25%,
                rgba(255, 255, 255, 0.06) 50%,
                rgba(255, 255, 255, 0.12) 75%,
                rgba(255, 255, 255, 0.32) 100%);
            box-shadow: 
                0 16px 50px rgba(0, 0, 0, 0.25),
                0 1px 0 rgba(255, 255, 255, 0.9) inset,
                0 -1px 0 rgba(0, 0, 0, 0.25) inset,
                0 0 0 1px rgba(255, 255, 255, 0.4),
                0 0 15px rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(25px) saturate(200%);
            -webkit-backdrop-filter: blur(25px) saturate(200%);
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #fff 0%, #e1e5f2 50%, #fff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.3);
        }

        .header p {
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.1rem;
            margin-bottom: 5px;
        }

        .header em {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.95rem;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 600;
            font-size: 14px;
        }

        input, select, button {
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.25) 0%, 
                rgba(255, 255, 255, 0.1) 50%,
                rgba(255, 255, 255, 0.2) 100%);
            backdrop-filter: blur(15px) saturate(150%);
            -webkit-backdrop-filter: blur(15px) saturate(150%);
            border: 1px solid transparent;
            color: #fff;
            padding: 10px 15px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.15),
                0 1px 0 rgba(255, 255, 255, 0.6) inset,
                0 -1px 0 rgba(0, 0, 0, 0.1) inset,
                0 0 0 1px rgba(255, 255, 255, 0.3);
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, 
                rgba(255, 255, 255, 0.25) 0%,
                transparent 100%);
            border-radius: 12px 12px 0 0;
            pointer-events: none;
        }

        input:focus, select:focus {
            outline: none;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.08) 100%);
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                0 0 0 3px rgba(255, 255, 255, 0.1);
        }

        button {
            cursor: pointer;
            font-weight: 600;
            text-align: center;
        }

        button:hover {
            transform: translateY(-3px) scale(1.02);
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.35) 0%, 
                rgba(255, 255, 255, 0.15) 50%,
                rgba(255, 255, 255, 0.25) 100%);
            backdrop-filter: blur(20px) saturate(200%);
            -webkit-backdrop-filter: blur(20px) saturate(200%);
            box-shadow: 
                0 12px 30px rgba(0, 0, 0, 0.25),
                0 1px 0 rgba(255, 255, 255, 0.8) inset,
                0 -1px 0 rgba(0, 0, 0, 0.15) inset,
                0 0 0 1px rgba(255, 255, 255, 0.5),
                0 0 15px rgba(255, 255, 255, 0.2);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .map-container {
            flex: 1;
            min-height: 400px;
        }

        .map-display {
            width: 100%;
            height: 500px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0.2) 100%);
            backdrop-filter: blur(15px);
            color: #fff;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1;
            padding: 15px;
            border-radius: 15px;
            overflow: auto;
            white-space: pre;
            border: 1px solid rgba(255, 255, 255, 0.2);
            resize: none;
            box-shadow: 
                inset 0 4px 15px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .stats-display {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.9);
            white-space: pre-line;
        }

        .notifications {
            max-height: 200px;
            overflow-y: auto;
            font-size: 13px;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.8);
        }

        .notification-item {
            padding: 8px;
            margin-bottom: 5px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.02) 100%);
            border-radius: 8px;
            border-left: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .legend {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.3;
            color: rgba(255, 255, 255, 0.9);
            white-space: pre;
        }

        .environment-info {
            text-align: center;
            font-size: 16px;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.95);
            margin-bottom: 15px;
            padding: 10px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border-radius: 10px;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.95) 0%, rgba(30, 30, 30, 0.95) 100%);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            margin: 3% auto;
            padding: 0;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .modal-header {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            padding: 20px 30px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            color: white;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .close {
            color: rgba(255, 255, 255, 0.7);
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close:hover {
            color: white;
        }

        .code-container {
            padding: 30px;
            max-height: 75vh;
            overflow-y: auto;
        }

        .code-block {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.6) 0%, rgba(0, 0, 0, 0.4) 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            overflow-x: auto;
            box-shadow: inset 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .code-block pre {
            color: #f8f8f2;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
            margin: 0;
            white-space: pre;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
                gap: 15px;
                padding: 60px 15px 15px;
            }
            
            .source-buttons {
                position: relative;
                top: 0;
                right: 0;
                justify-content: center;
                margin-bottom: 20px;
            }

            .back-button {
                position: relative;
                top: 0;
                left: 0;
                display: inline-block;
                margin-bottom: 20px;
            }

            .header h1 {
                font-size: 2rem;
            }
        }

        /* Map colors */
        .water { color: #4a90a4; }
        .grass { color: #7ba428; }
        .mountain { color: #8b7355; }
        .gold { color: #cc9900; }
        .port { color: #8e6a5b; }
        .forest { color: #5d7c47; }
        .farm { color: #b8860b; }
        .ruins { color: #a0826d; }
        .grave { color: #666666; }
        .dwarf { color: #e67e22; background-color: rgba(52, 73, 94, 0.3); }
        .deer { color: #daa520; }
        .wolf { color: #cd5c5c; }
        .building { color: #9b59b6; }
        .corpse { color: #ff4444; }
    </style>
</head>
<body>
    <canvas class="background-canvas"></canvas>

    <a href="../" class="back-button">‚Üê Back to Portfolio</a>

    <div class="source-buttons">
        <button class="source-btn" onclick="showPythonCode()">üêç Python Code</button>
        <button class="source-btn" onclick="showHTMLCode()">üåê HTML Code</button>
    </div>

    <div class="main-container">
        <div class="left-panel">
            <div class="glass-panel">
                <div class="header">
                    <h1><span class="text">ASCII Dwarf Simulation</span></h1>
                    <p>Watch dwarfs build a thriving civilization in ASCII art</p>
                    <p><em>Complex AI simulation originally developed in Python</em></p>
                </div>

                <div class="environment-info" id="environmentInfo">
                    üå∏ Spring | ‚òÄÔ∏è Sunny | Year 1, Day 1
                </div>

                <div class="controls">
                    <div class="control-group">
                        <label>üó∫Ô∏è Map Size</label>
                        <select id="mapSize">
                            <option value="small">Small (50x25)</option>
                            <option value="medium" selected>Medium (80x40)</option>
                            <option value="large">Large (120x60)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>üßî Starting Dwarfs</label>
                        <input type="number" id="dwarfCount" value="15" min="5" max="50">
                    </div>
                    <div class="control-group">
                        <label>‚ö° Simulation Speed</label>
                        <select id="simSpeed">
                            <option value="slow">Slow (2s)</option>
                            <option value="medium" selected>Medium (1s)</option>
                            <option value="fast">Fast (0.5s)</option>
                            <option value="turbo">Turbo (0.2s)</option>
                        </select>
                    </div>
                </div>

                <div class="controls">
                    <button id="generateBtn">üé≤ Generate New World</button>
                    <button id="startBtn">‚ñ∂Ô∏è Start Civilization</button>
                    <button id="pauseBtn" disabled>‚è∏Ô∏è Pause</button>
                    <button id="resetBtn">üîÑ Reset World</button>
                </div>
            </div>

            <div class="glass-panel map-container">
                <h3>üó∫Ô∏è Dwarf World</h3>
                <textarea class="map-display" id="mapDisplay" readonly 
                          placeholder="Generate a world to begin the simulation..."></textarea>
            </div>
        </div>

        <div class="right-panel">
            <div class="glass-panel">
                <h3>üìä Civilization Statistics</h3>
                <div class="stats-display" id="statsDisplay">
üë• Population: 0
üí∞ Total Wealth: 0
üíñ Avg Health: 0/100
üòä Avg Happiness: 0/100
üèóÔ∏è Buildings: 0
‚öîÔ∏è Battles: 0
                </div>
            </div>

            <div class="glass-panel">
                <h3>üì¢ World Events</h3>
                <div class="notifications" id="notifications">
                    <div class="notification-item">üåç Welcome to the ASCII Dwarf Simulation!</div>
                    <div class="notification-item">üéÆ Generate a world and start your civilization!</div>
                </div>
            </div>

            <div class="glass-panel">
                <h3>üóÇÔ∏è Legend</h3>
                <div class="legend">üåä ~ Water    üå± . Grass    üèîÔ∏è ^ Mountain
üí∞ G Mine     üö¢ P Port     üå≤ T Forest  
üèõÔ∏è R Ruins    üåæ F Farm     ‚úù ‚úù Grave
üè† H House    üç∫ V Tavern   üî® W Workshop
üßî D Dwarf    ‚ò† ‚ò† Corpse   ü¶å Deer üê∫ Wolf</div>
            </div>
        </div>
    </div>

    <!-- Python Code Modal -->
    <div id="pythonModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">üêç Original Python Source Code</h2>
                <span class="close" onclick="closeModal('pythonModal')">&times;</span>
            </div>
            <div class="code-container">
                <div class="code-block">
                    <pre id="pythonCodeContent">Loading Python code...</pre>
                </div>
            </div>
        </div>
    </div>

    <!-- HTML Code Modal -->
    <div id="htmlModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">üåê HTML/JavaScript Source Code</h2>
                <span class="close" onclick="closeModal('htmlModal')">&times;</span>
            </div>
            <div class="code-container">
                <div class="code-block">
                    <pre id="htmlCodeContent">Loading HTML code...</pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        class DwarfSimulation {
            constructor() {
                this.map = null;
                this.dwarfs = [];
                this.animals = [];
                this.corpses = [];
                this.buildings = new Map();
                
                this.running = false;
                this.gameTime = 0;
                this.day = 1;
                this.year = 1;
                this.season = 'Spring';
                this.weather = 'Sunny';
                
                this.notifications = [];
                this.maxNotifications = 20;
                
                this.terrainTypes = {
                    WATER: '~',
                    GRASS: '.',
                    MOUNTAIN: '^',
                    GOLD_MINE: 'G',
                    PORT: 'P',
                    FOREST: 'T',
                    FARM: 'F',
                    RUINS: 'R',
                    GRAVE: '‚úù',
                    HOUSE: 'H',
                    TAVERN: 'V',
                    WORKSHOP: 'W'
                };
                
                this.dwarfNames = [
                    'Thorin', 'Balin', 'Dwalin', 'Gimli', 'Legolas', 'Groin', 'Fundin',
                    'Bjorn', 'Erik', 'Gunnar', 'Harald', 'Magnus', 'Olaf', 'Ragnar',
                    'Hamish', 'Duncan', 'Fergus', 'Ian', 'Malcolm', 'Wallace',
                    'Bruno', 'Conrad', 'Franz', 'Gustav', 'Karl', 'Ludwig',
                    'Ironbeard', 'Stoneaxe', 'Goldbeard', 'Steelhammer', 'Albert'
                ];
                
                this.initializeElements();
                this.bindEvents();
                this.addNotification("üåç Welcome to Albert's ASCII Dwarf Simulation!");
                this.addNotification("üéÆ Create a world and watch dwarfs build their civilization!");
            }
            
            initializeElements() {
                this.mapSizeSelect = document.getElementById('mapSize');
                this.dwarfCountInput = document.getElementById('dwarfCount');
                this.simSpeedSelect = document.getElementById('simSpeed');
                this.generateBtn = document.getElementById('generateBtn');
                this.startBtn = document.getElementById('startBtn');
                this.pauseBtn = document.getElementById('pauseBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.mapDisplay = document.getElementById('mapDisplay');
                this.statsDisplay = document.getElementById('statsDisplay');
                this.notificationsDiv = document.getElementById('notifications');
                this.environmentInfo = document.getElementById('environmentInfo');
            }
            
            bindEvents() {
                this.generateBtn.addEventListener('click', () => this.generateWorld());
                this.startBtn.addEventListener('click', () => this.startSimulation());
                this.pauseBtn.addEventListener('click', () => this.pauseSimulation());
                this.resetBtn.addEventListener('click', () => this.resetSimulation());
            }
            
            generateWorld() {
                const mapSizes = {
                    small: [50, 25],
                    medium: [80, 40],
                    large: [120, 60]
                };
                
                const [width, height] = mapSizes[this.mapSizeSelect.value];
                this.map = this.createMap(width, height);
                this.dwarfs = [];
                this.animals = [];
                this.corpses = [];
                this.buildings.clear();
                
                this.generateAnimals();
                this.updateDisplay();
                this.addNotification(`üó∫Ô∏è New ${width}x${height} world generated!`);
                this.addNotification("üßî Ready to spawn dwarfs and begin civilization!");
            }
            
            createMap(width, height) {
                const map = Array(height).fill().map(() => Array(width).fill(this.terrainTypes.WATER));
                
                // Generate landmasses using simplified noise
                const numIslands = Math.floor(Math.random() * 3) + 2;
                const islandCenters = [];
                
                for (let i = 0; i < numIslands; i++) {
                    islandCenters.push({
                        x: Math.floor(Math.random() * width),
                        y: Math.floor(Math.random() * height),
                        radius: Math.floor(Math.random() * Math.min(width, height) / 4) + 10
                    });
                }
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let minDistance = Infinity;
                        for (const island of islandCenters) {
                            const distance = Math.sqrt((x - island.x) ** 2 + (y - island.y) ** 2);
                            minDistance = Math.min(minDistance, distance / island.radius);
                        }
                        
                        const noise = this.simpleNoise(x * 0.1, y * 0.1) * 0.3;
                        const terrainValue = minDistance + noise;
                        
                        if (terrainValue < 0.8) {
                            if (terrainValue < 0.3 && Math.random() > 0.7) {
                                map[y][x] = this.terrainTypes.MOUNTAIN;
                            } else {
                                map[y][x] = this.terrainTypes.GRASS;
                            }
                        }
                    }
                }
                
                // Add special terrain
                this.addSpecialTerrain(map, width, height);
                
                return { terrain: map, width, height };
            }
            
            simpleNoise(x, y) {
                const n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
                return (n - Math.floor(n)) * 2 - 1;
            }
            
            addSpecialTerrain(map, width, height) {
                const grassTiles = [];
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (map[y][x] === this.terrainTypes.GRASS) {
                            grassTiles.push({ x, y });
                        }
                    }
                }
                
                // Add gold mines
                const numMines = Math.floor(grassTiles.length / 100) + 2;
                for (let i = 0; i < numMines && grassTiles.length > 0; i++) {
                    const index = Math.floor(Math.random() * grassTiles.length);
                    const { x, y } = grassTiles.splice(index, 1)[0];
                    map[y][x] = this.terrainTypes.GOLD_MINE;
                }
                
                // Add forests
                const numForests = Math.floor(grassTiles.length / 80);
                for (let i = 0; i < numForests && grassTiles.length > 0; i++) {
                    const index = Math.floor(Math.random() * grassTiles.length);
                    const { x, y } = grassTiles.splice(index, 1)[0];
                    map[y][x] = this.terrainTypes.FOREST;
                }
                
                // Add ports near water
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        if (map[y][x] === this.terrainTypes.GRASS && Math.random() < 0.02) {
                            let hasWaterNeighbor = false;
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (map[y + dy][x + dx] === this.terrainTypes.WATER) {
                                        hasWaterNeighbor = true;
                                        break;
                                    }
                                }
                                if (hasWaterNeighbor) break;
                            }
                            if (hasWaterNeighbor) {
                                map[y][x] = this.terrainTypes.PORT;
                            }
                        }
                    }
                }
                
                // Add ruins
                const numRuins = Math.floor(Math.random() * 5) + 2;
                for (let i = 0; i < numRuins && grassTiles.length > 0; i++) {
                    const index = Math.floor(Math.random() * grassTiles.length);
                    const { x, y } = grassTiles.splice(index, 1)[0];
                    map[y][x] = this.terrainTypes.RUINS;
                }
            }
            
            generateAnimals() {
                if (!this.map) return;
                
                const grassTiles = [];
                for (let y = 0; y < this.map.height; y++) {
                    for (let x = 0; x < this.map.width; x++) {
                        if (this.map.terrain[y][x] === this.terrainTypes.GRASS || 
                            this.map.terrain[y][x] === this.terrainTypes.FOREST) {
                            grassTiles.push({ x, y });
                        }
                    }
                }
                
                // Add deer
                const numDeer = Math.floor(grassTiles.length / 200) + 5;
                for (let i = 0; i < numDeer && grassTiles.length > 0; i++) {
                    const index = Math.floor(Math.random() * grassTiles.length);
                    const { x, y } = grassTiles.splice(index, 1)[0];
                    this.animals.push({
                        x, y, type: 'deer', health: 100, age: 0, alive: true
                    });
                }
                
                // Add wolves (fewer)
                const numWolves = Math.floor(grassTiles.length / 500) + 2;
                for (let i = 0; i < numWolves && grassTiles.length > 0; i++) {
                    const index = Math.floor(Math.random() * grassTiles.length);
                    const { x, y } = grassTiles.splice(index, 1)[0];
                    this.animals.push({
                        x, y, type: 'wolf', health: 150, age: 0, alive: true
                    });
                }
            }
            
            startSimulation() {
                if (!this.map) {
                    this.addNotification("‚ùå Generate a world first!");
                    return;
                }
                
                if (this.dwarfs.length === 0) {
                    this.generateDwarfs();
                }
                
                this.running = true;
                this.startBtn.disabled = true;
                this.pauseBtn.disabled = false;
                this.generateBtn.disabled = true;
                
                this.addNotification("üé¨ Civilization begins! Watch the dwarfs live their lives!");
                this.simulationLoop();
            }
            
            pauseSimulation() {
                this.running = false;
                this.startBtn.disabled = false;
                this.pauseBtn.disabled = true;
                this.generateBtn.disabled = false;
                this.addNotification("‚è∏Ô∏è Simulation paused.");
            }
            
            resetSimulation() {
                this.running = false;
                this.gameTime = 0;
                this.day = 1;
                this.year = 1;
                this.season = 'Spring';
                this.weather = 'Sunny';
                this.dwarfs = [];
                this.animals = [];
                this.corpses = [];
                this.buildings.clear();
                this.notifications = [];
                
                this.startBtn.disabled = false;
                this.pauseBtn.disabled = true;
                this.generateBtn.disabled = false;
                
                if (this.map) {
                    this.generateAnimals();
                    this.updateDisplay();
                }
                
                this.addNotification("üîÑ World reset! Ready for a new civilization!");
                this.updateEnvironmentDisplay();
            }
            
            generateDwarfs() {
                const count = parseInt(this.dwarfCountInput.value);
                const grassTiles = [];
                
                for (let y = 0; y < this.map.height; y++) {
                    for (let x = 0; x < this.map.width; x++) {
                        if (this.map.terrain[y][x] === this.terrainTypes.GRASS) {
                            grassTiles.push({ x, y });
                        }
                    }
                }
                
                const actualCount = Math.min(count, grassTiles.length);
                
                for (let i = 0; i < actualCount; i++) {
                    const index = Math.floor(Math.random() * grassTiles.length);
                    const { x, y } = grassTiles.splice(index, 1)[0];
                    
                    let name = this.dwarfNames[Math.floor(Math.random() * this.dwarfNames.length)];
                    let nameCounter = 1;
                    const originalName = name;
                    
                    while (this.dwarfs.some(d => d.name === name)) {
                        name = `${originalName}${nameCounter}`;
                        nameCounter++;
                    }
                    
                    const dwarf = {
                        x, y,
                        name,
                        age: Math.floor(Math.random() * 30) + 18,
                        gender: Math.random() < 0.5 ? 'M' : 'F',
                        health: 100,
                        happiness: 100,
                        hunger: 80,
                        gold: Math.floor(Math.random() * 20),
                        alive: true,
                        state: 'wandering',
                        stateTimer: 0,
                        targetX: x,
                        targetY: y,
                        profession: 'Citizen',
                        skills: this.generateSkills(),
                        relationships: new Map(),
                        inventory: { food: 10, tools: 0, weapons: 0 },
                        kills: 0,
                        buildings: 0,
                        lifeEvents: []
                    };
                    
                    this.dwarfs.push(dwarf);
                }
                
                this.addNotification(`üßî ${actualCount} brave dwarfs have founded the settlement!`);
            }
            
            generateSkills() {
                return {
                    mining: Math.floor(Math.random() * 20) + 1,
                    fishing: Math.floor(Math.random() * 20) + 1,
                    building: Math.floor(Math.random() * 20) + 1,
                    farming: Math.floor(Math.random() * 20) + 1,
                    hunting: Math.floor(Math.random() * 20) + 1,
                    combat: Math.floor(Math.random() * 20) + 1,
                    trading: Math.floor(Math.random() * 20) + 1
                };
            }
            
            simulationLoop() {
                if (!this.running) return;
                
                this.gameTime++;
                
                // Update environment every 50 ticks
                if (this.gameTime % 50 === 0) {
                    this.updateEnvironment();
                }
                
                // Age population every 500 ticks
                if (this.gameTime % 500 === 0) {
                    this.agePopulation();
                }
                
                this.updateDwarfs();
                this.updateAnimals();
                this.updateDisplay();
                this.updateStats();
                
                const speeds = { slow: 2000, medium: 1000, fast: 500, turbo: 200 };
                const delay = speeds[this.simSpeedSelect.value] || 1000;
                
                setTimeout(() => this.simulationLoop(), delay);
            }
            
            updateEnvironment() {
                this.day++;
                
                if (this.day % 30 === 0) {
                    const seasons = ['Spring', 'Summer', 'Autumn', 'Winter'];
                    const currentIndex = seasons.indexOf(this.season);
                    this.season = seasons[(currentIndex + 1) % seasons.length];
                    
                    if (this.season === 'Spring') {
                        this.year++;
                    }
                    
                    this.addNotification(`üåç ${this.season} has arrived! Year ${this.year}`);
                }
                
                if (Math.random() < 0.3) {
                    const weathers = ['Sunny', 'Rainy', 'Stormy', 'Foggy'];
                    this.weather = weathers[Math.floor(Math.random() * weathers.length)];
                }
                
                this.updateEnvironmentDisplay();
            }
            
            updateEnvironmentDisplay() {
                const seasonEmojis = { Spring: 'üå∏', Summer: '‚òÄÔ∏è', Autumn: 'üçÇ', Winter: '‚ùÑÔ∏è' };
                const weatherEmojis = { Sunny: '‚òÄÔ∏è', Rainy: 'üåßÔ∏è', Stormy: '‚õàÔ∏è', Foggy: 'üå´Ô∏è' };
                
                this.environmentInfo.textContent = 
                    `${seasonEmojis[this.season]} ${this.season} | ${weatherEmojis[this.weather]} ${this.weather} | Year ${this.year}, Day ${this.day}`;
            }
            
            agePopulation() {
                let deaths = 0;
                
                this.dwarfs.forEach(dwarf => {
                    if (!dwarf.alive) return;
                    
                    dwarf.age++;
                    
                    if (dwarf.age > 70 && Math.random() < 0.01) {
                        dwarf.health -= Math.floor(Math.random() * 10);
                    }
                    
                    if (dwarf.age > 90 && Math.random() < 0.02) {
                        dwarf.alive = false;
                        dwarf.health = 0;
                        deaths++;
                        this.corpses.push({
                            x: dwarf.x,
                            y: dwarf.y,
                            name: dwarf.name,
                            age: dwarf.age,
                            timeSinceDeath: 0
                        });
                    }
                });
                
                if (deaths > 0) {
                    this.addNotification(`üìä ${deaths} dwarfs died of old age this year`);
                }
            }
            
            updateDwarfs() {
                this.dwarfs.forEach(dwarf => {
                    if (!dwarf.alive) return;
                    
                    dwarf.stateTimer = Math.max(0, dwarf.stateTimer - 1);
                    dwarf.hunger = Math.max(0, dwarf.hunger - 0.1);
                    dwarf.happiness = Math.max(0, dwarf.happiness - 0.05);
                    
                    if (dwarf.hunger < 20) {
                        dwarf.health = Math.max(0, dwarf.health - 0.2);
                    }
                    
                    // Auto-eat food when hungry
                    if (dwarf.hunger < 50 && dwarf.inventory.food > 0) {
                        dwarf.inventory.food--;
                        dwarf.hunger = Math.min(100, dwarf.hunger + 20);
                        dwarf.health = Math.min(100, dwarf.health + 5);
                    }
                    
                    this.updateDwarfState(dwarf);
                    this.moveDwarf(dwarf);
                    this.checkDwarfInteractions(dwarf);
                });
            }
            
            updateDwarfState(dwarf) {
                if (dwarf.state === 'mining' && dwarf.stateTimer <= 0) {
                    const goldMined = Math.floor(Math.random() * 5) + 1;
                    dwarf.gold += goldMined;
                    dwarf.skills.mining++;
                    dwarf.state = 'resting';
                    dwarf.stateTimer = 20;
                    this.setRandomTarget(dwarf);
                    this.addNotification(`‚õèÔ∏è ${dwarf.name} mined ${goldMined} gold!`);
                    
                } else if (dwarf.state === 'fishing' && dwarf.stateTimer <= 0) {
                    const foodCaught = Math.floor(Math.random() * 5) + 2;
                    const goldEarned = Math.floor(Math.random() * 3) + 1;
                    dwarf.inventory.food += foodCaught;
                    dwarf.gold += goldEarned;
                    dwarf.skills.fishing++;
                    dwarf.state = 'resting';
                    dwarf.stateTimer = 15;
                    this.setRandomTarget(dwarf);
                    this.addNotification(`üé£ ${dwarf.name} caught ${foodCaught} food!`);
                    
                } else if (dwarf.state === 'building' && dwarf.stateTimer <= 0) {
                    if (this.tryBuildStructure(dwarf)) {
                        dwarf.skills.building++;
                        dwarf.buildings++;
                    }
                    dwarf.state = 'resting';
                    dwarf.stateTimer = 30;
                    this.setRandomTarget(dwarf);
                    
                } else if (dwarf.state === 'resting' && dwarf.stateTimer <= 0) {
                    dwarf.health = Math.min(100, dwarf.health + 3);
                    dwarf.happiness = Math.min(100, dwarf.happiness + 2);
                    dwarf.state = 'wandering';
                    this.setRandomTarget(dwarf);
                    
                } else if (dwarf.state === 'fighting' && dwarf.stateTimer <= 0) {
                    dwarf.state = 'wandering';
                    this.setRandomTarget(dwarf);
                }
            }
            
            moveDwarf(dwarf) {
                if (dwarf.state !== 'wandering') return;
                
                const dx = Math.sign(dwarf.targetX - dwarf.x);
                const dy = Math.sign(dwarf.targetY - dwarf.y);
                
                const newX = dwarf.x + (Math.random() < 0.7 ? dx : 0);
                const newY = dwarf.y + (Math.random() < 0.7 ? dy : 0);
                
                if (this.isWalkable(newX, newY) && !this.isDwarfAt(newX, newY)) {
                    dwarf.x = newX;
                    dwarf.y = newY;
                }
                
                if (dwarf.x === dwarf.targetX && dwarf.y === dwarf.targetY) {
                    this.setRandomTarget(dwarf);
                }
            }
            
            setRandomTarget(dwarf) {
                dwarf.targetX = Math.max(0, Math.min(this.map.width - 1, 
                    dwarf.x + Math.floor(Math.random() * 21) - 10));
                dwarf.targetY = Math.max(0, Math.min(this.map.height - 1, 
                    dwarf.y + Math.floor(Math.random() * 21) - 10));
            }
            
            isWalkable(x, y) {
                if (x < 0 || x >= this.map.width || y < 0 || y >= this.map.height) return false;
                
                const terrain = this.map.terrain[y][x];
                return terrain !== this.terrainTypes.WATER && terrain !== this.terrainTypes.MOUNTAIN;
            }
            
            isDwarfAt(x, y) {
                return this.dwarfs.some(d => d.alive && d.x === x && d.y === y);
            }
            
            checkDwarfInteractions(dwarf) {
                if (dwarf.state !== 'wandering') return;
                
                const terrain = this.map.terrain[dwarf.y][dwarf.x];
                
                // Terrain-based activities
                if (terrain === this.terrainTypes.GOLD_MINE && Math.random() < 0.3) {
                    dwarf.state = 'mining';
                    dwarf.stateTimer = 8;
                    return;
                }
                
                if (terrain === this.terrainTypes.PORT && Math.random() < 0.3) {
                    dwarf.state = 'fishing';
                    dwarf.stateTimer = 6;
                    return;
                }
                
                if (terrain === this.terrainTypes.GRASS && Math.random() < 0.1) {
                    dwarf.state = 'building';
                    dwarf.stateTimer = 12;
                    return;
                }
                
                // Check for other dwarfs nearby
                const nearbyDwarfs = this.dwarfs.filter(other => 
                    other !== dwarf && other.alive &&
                    Math.abs(other.x - dwarf.x) <= 1 && Math.abs(other.y - dwarf.y) <= 1
                );
                
                if (nearbyDwarfs.length > 0) {
                    const other = nearbyDwarfs[Math.floor(Math.random() * nearbyDwarfs.length)];
                    this.handleDwarfInteraction(dwarf, other);
                }
            }
            
            handleDwarfInteraction(dwarf1, dwarf2) {
                const action = Math.random();
                
                if (action < 0.1) {
                    this.dwarfFight(dwarf1, dwarf2);
                } else if (action < 0.3) {
                    this.dwarfTrade(dwarf1, dwarf2);
                } else if (action < 0.5) {
                    this.dwarfSocialize(dwarf1, dwarf2);
                } else if (action < 0.6 && dwarf1.gender !== dwarf2.gender) {
                    this.dwarfReproduce(dwarf1, dwarf2);
                }
            }
            
            dwarfFight(dwarf1, dwarf2) {
                dwarf1.state = 'fighting';
                dwarf2.state = 'fighting';
                dwarf1.stateTimer = 5;
                dwarf2.stateTimer = 5;
                
                const power1 = dwarf1.health + dwarf1.skills.combat * 2;
                const power2 = dwarf2.health + dwarf2.skills.combat * 2;
                
                const winner = power1 > power2 ? dwarf1 : dwarf2;
                const loser = power1 > power2 ? dwarf2 : dwarf1;
                
                const goldStolen = Math.min(loser.gold, Math.floor(Math.random() * 5) + 1);
                winner.gold += goldStolen;
                loser.gold -= goldStolen;
                
                const damage = Math.floor(Math.random() * 15) + 10;
                loser.health -= damage;
                winner.health -= Math.floor(Math.random() * 8) + 2;
                
                winner.skills.combat++;
                loser.skills.combat++;
                
                if (loser.health <= 0) {
                    loser.alive = false;
                    winner.kills++;
                    this.corpses.push({
                        x: loser.x, y: loser.y, name: loser.name, age: loser.age, timeSinceDeath: 0
                    });
                    this.addNotification(`‚öîÔ∏è ${winner.name} killed ${loser.name} in combat!`);
                } else {
                    this.addNotification(`‚öîÔ∏è ${winner.name} defeated ${loser.name} and stole ${goldStolen} gold!`);
                }
            }
            
            dwarfTrade(dwarf1, dwarf2) {
                if (dwarf1.inventory.food > dwarf2.inventory.food && dwarf2.gold > dwarf1.gold) {
                    const foodTraded = Math.min(2, dwarf1.inventory.food);
                    const goldTraded = Math.min(3, dwarf2.gold);
                    
                    dwarf1.inventory.food -= foodTraded;
                    dwarf1.gold += goldTraded;
                    dwarf2.inventory.food += foodTraded;
                    dwarf2.gold -= goldTraded;
                    
                    this.addNotification(`üíº ${dwarf1.name} traded ${foodTraded} food for ${goldTraded} gold with ${dwarf2.name}!`);
                }
            }
            
            dwarfSocialize(dwarf1, dwarf2) {
                dwarf1.happiness = Math.min(100, dwarf1.happiness + 5);
                dwarf2.happiness = Math.min(100, dwarf2.happiness + 5);
                
                if (Math.random() < 0.1) {
                    this.addNotification(`ü§ù ${dwarf1.name} and ${dwarf2.name} became friends!`);
                }
            }
            
            dwarfReproduce(dwarf1, dwarf2) {
                // Find empty spot near parents
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const x = dwarf1.x + dx;
                        const y = dwarf1.y + dy;
                        
                        if (this.isWalkable(x, y) && !this.isDwarfAt(x, y)) {
                            const parentName = Math.random() < 0.5 ? dwarf1.name : dwarf2.name;
                            let childName = `${parentName}Jr`;
                            let counter = 1;
                            
                            while (this.dwarfs.some(d => d.name === childName)) {
                                childName = `${parentName}Jr${counter}`;
                                counter++;
                            }
                            
                            const child = {
                                x, y, name: childName,
                                age: 0,
                                gender: Math.random() < 0.5 ? 'M' : 'F',
                                health: 100, happiness: 100, hunger: 80,
                                gold: 0, alive: true,
                                state: 'wandering', stateTimer: 0,
                                targetX: x, targetY: y,
                                profession: 'Citizen',
                                skills: this.generateSkills(),
                                relationships: new Map(),
                                inventory: { food: 5, tools: 0, weapons: 0 },
                                kills: 0, buildings: 0, lifeEvents: []
                            };
                            
                            this.dwarfs.push(child);
                            this.addNotification(`üë∂ ${childName} was born to ${dwarf1.name} and ${dwarf2.name}!`);
                            return;
                        }
                    }
                }
            }
            
            tryBuildStructure(dwarf) {
                const buildingTypes = [this.terrainTypes.HOUSE, this.terrainTypes.TAVERN, this.terrainTypes.WORKSHOP];
                const buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                
                // Try to build near current position
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const x = dwarf.x + dx;
                        const y = dwarf.y + dy;
                        
                        if (x >= 0 && x < this.map.width && y >= 0 && y < this.map.height &&
                            this.map.terrain[y][x] === this.terrainTypes.GRASS && 
                            !this.buildings.has(`${x},${y}`)) {
                            
                            this.buildings.set(`${x},${y}`, buildingType);
                            
                            const buildingNames = {
                                [this.terrainTypes.HOUSE]: 'house',
                                [this.terrainTypes.TAVERN]: 'tavern',
                                [this.terrainTypes.WORKSHOP]: 'workshop'
                            };
                            
                            this.addNotification(`üèóÔ∏è ${dwarf.name} built a ${buildingNames[buildingType]}!`);
                            return true;
                        }
                    }
                }
                return false;
            }
            
            updateAnimals() {
                this.animals.forEach(animal => {
                    if (!animal.alive) return;
                    
                    animal.age++;
                    
                    // Animals move randomly
                    if (Math.random() < 0.3) {
                        const newX = animal.x + Math.floor(Math.random() * 3) - 1;
                        const newY = animal.y + Math.floor(Math.random() * 3) - 1;
                        
                        if (this.isWalkable(newX, newY)) {
                            animal.x = newX;
                            animal.y = newY;
                        }
                    }
                    
                    // Animals die of old age
                    if (animal.age > 200 && Math.random() < 0.01) {
                        animal.alive = false;
                    }
                });
            }
            
            updateDisplay() {
                if (!this.map) return;
                
                const display = Array(this.map.height).fill().map(() => Array(this.map.width).fill(' '));
                
                // Draw terrain
                for (let y = 0; y < this.map.height; y++) {
                    for (let x = 0; x < this.map.width; x++) {
                        display[y][x] = this.map.terrain[y][x];
                    }
                }
                
                // Draw buildings
                this.buildings.forEach((buildingType, key) => {
                    const [x, y] = key.split(',').map(Number);
                    if (x >= 0 && x < this.map.width && y >= 0 && y < this.map.height) {
                        display[y][x] = buildingType;
                    }
                });
                
                // Draw animals
                this.animals.forEach(animal => {
                    if (animal.alive && animal.x >= 0 && animal.x < this.map.width && 
                        animal.y >= 0 && animal.y < this.map.height) {
                        display[animal.y][animal.x] = animal.type === 'deer' ? 'D' : 'W';
                    }
                });
                
                // Draw corpses
                this.corpses.forEach(corpse => {
                    if (corpse.x >= 0 && corpse.x < this.map.width && 
                        corpse.y >= 0 && corpse.y < this.map.height) {
                        display[corpse.y][corpse.x] = '‚ò†';
                    }
                });
                
                // Draw dwarfs (they override everything else)
                this.dwarfs.forEach(dwarf => {
                    if (dwarf.alive && dwarf.x >= 0 && dwarf.x < this.map.width && 
                        dwarf.y >= 0 && dwarf.y < this.map.height) {
                        display[dwarf.y][dwarf.x] = 'D';
                    }
                });
                
                const mapString = display.map(row => row.join('')).join('\n');
                this.mapDisplay.value = mapString;
            }
            
            updateStats() {
                const aliveDwarfs = this.dwarfs.filter(d => d.alive);
                const totalGold = aliveDwarfs.reduce((sum, d) => sum + d.gold, 0);
                const avgHealth = aliveDwarfs.length > 0 ? 
                    aliveDwarfs.reduce((sum, d) => sum + d.health, 0) / aliveDwarfs.length : 0;
                const avgHappiness = aliveDwarfs.length > 0 ? 
                    aliveDwarfs.reduce((sum, d) => sum + d.happiness, 0) / aliveDwarfs.length : 0;
                
                const males = aliveDwarfs.filter(d => d.gender === 'M').length;
                const females = aliveDwarfs.filter(d => d.gender === 'F').length;
                
                const totalKills = aliveDwarfs.reduce((sum, d) => sum + d.kills, 0);
                const totalBuildings = this.buildings.size;
                
                const aliveAnimals = this.animals.filter(a => a.alive);
                const deer = aliveAnimals.filter(a => a.type === 'deer').length;
                const wolves = aliveAnimals.filter(a => a.type === 'wolf').length;
                
                this.statsDisplay.textContent = `üë• Population: ${aliveDwarfs.length} (‚ôÇÔ∏è${males} | ‚ôÄÔ∏è${females})
üí∞ Total Wealth: ${totalGold}
üíñ Avg Health: ${avgHealth.toFixed(1)}/100
üòä Avg Happiness: ${avgHappiness.toFixed(1)}/100
üèóÔ∏è Buildings: ${totalBuildings}
‚öîÔ∏è Total Battles: ${totalKills}
üåç Wildlife: ü¶å${deer} | üê∫${wolves}
‚ò† Corpses: ${this.corpses.length}
‚è∞ Game Time: ${this.gameTime} ticks`;
            }
            
            addNotification(message) {
                const timestamp = new Date().toLocaleTimeString();
                this.notifications.unshift(`[${timestamp}] ${message}`);
                
                if (this.notifications.length > this.maxNotifications) {
                    this.notifications = this.notifications.slice(0, this.maxNotifications);
                }
                
                this.updateNotificationDisplay();
            }
            
            updateNotificationDisplay() {
                this.notificationsDiv.innerHTML = this.notifications
                    .map(notification => `<div class="notification-item">${notification}</div>`)
                    .join('');
            }
        }

        // Source code loading functions
        async function loadSourceCode(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.text();
            } catch (error) {
                console.error('Error loading source code:', error);
                return `Error loading source code: ${error.message}\n\nNote: Make sure the ${filename} file is in the same directory as this HTML file.`;
            }
        }

        async function showPythonCode() {
            const codeContent = document.getElementById('pythonCodeContent');
            codeContent.innerHTML = '<div class="loading"></div> Loading Python source code...';
            document.getElementById('pythonModal').style.display = 'block';
            
            const pythonCode = await loadSourceCode('dwarf_simulation.py');
            codeContent.textContent = pythonCode;
        }

        async function showHTMLCode() {
            const codeContent = document.getElementById('htmlCodeContent');
            codeContent.innerHTML = '<div class="loading"></div> Loading HTML source code...';
            document.getElementById('htmlModal').style.display = 'block';
            
            // For HTML, we can show the current document
            const htmlCode = document.documentElement.outerHTML;
            codeContent.textContent = htmlCode;
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const pythonModal = document.getElementById('pythonModal');
            const htmlModal = document.getElementById('htmlModal');
            if (event.target == pythonModal) {
                pythonModal.style.display = 'none';
            }
            if (event.target == htmlModal) {
                htmlModal.style.display = 'none';
            }
        }

        // Initialize the simulation when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new DwarfSimulation();
        });

        // WebGL Lava Lamp Background
        window.addEventListener('load', () => {
            const canvas = document.querySelector('.background-canvas');
            const gl = canvas.getContext("webgl");
            if (!gl) {
                console.error("WebGL not supported");
                return;
            }

            let width = canvas.width = window.innerWidth;
            let height = canvas.height = window.innerHeight;

            function resizeCanvas() {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
                gl.viewport(0, 0, width, height);
            }
            window.addEventListener("resize", resizeCanvas);

            let mouse = { x: width / 2, y: height / 2 };
            function onMouseMove(e) {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
            }
            window.addEventListener("mousemove", onMouseMove);

            const circleColors = [
                [18 / 255, 113 / 255, 1.0],
                [221 / 255, 74 / 255, 1.0],
                [100 / 255, 220 / 255, 1.0],
                [200 / 255, 50 / 255, 50 / 255],
                [180 / 255, 180 / 255, 50 / 255],
                [140 / 255, 100 / 255, 1.0],
            ];

            let circles = [];
            function initCircles() {
                circles = [];
                const baseRadius = (width + height) * 0.2;
                for (let i = 0; i < 5; i++) {
                    const radius = baseRadius;
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    const speedMultiplier = Math.random() * 4 + 1;
                    const vx = (Math.random() - 0.5) * speedMultiplier;
                    const vy = (Math.random() - 0.5) * speedMultiplier;
                    circles.push({
                        x,
                        y,
                        radius,
                        color: circleColors[i],
                        vx,
                        vy,
                        interactive: false,
                    });
                }

                // interactive circle
                const interactiveRadius = (width + height) * 0.1;
                circles.push({
                    x: width / 2,
                    y: height / 2,
                    radius: interactiveRadius,
                    color: circleColors[5],
                    vx: 0,
                    vy: 0,
                    interactive: true,
                });
            }

            initCircles();

            const vertexSrc = `
                attribute vec2 a_position;
                varying vec2 v_uv;
                void main(void) {
                    v_uv = a_position * 0.5 + 0.5; 
                    v_uv.y = 1.0 - v_uv.y; 
                    gl_Position = vec4(a_position, 0.0, 1.0);
                }
            `;

            const fragmentSrc = `
                precision mediump float;
                varying vec2 v_uv;

                uniform vec2 u_resolution;
                uniform bool u_darkMode;
                uniform int u_circleCount;
                uniform vec3 u_circlesColor[6];
                uniform vec3 u_circlesPosRad[6];
                uniform vec2 u_mouse;

                void main(void) {
                    vec2 st = v_uv * u_resolution;

                    vec3 topColor = vec3(108.0/255.0, 0.0, 162.0/255.0);
                    vec3 bottomColor = vec3(0.0, 17.0/255.0, 82.0/255.0);
                    vec3 bgColor = mix(topColor, bottomColor, st.y / u_resolution.y);

                    float fieldSum = 0.0;
                    vec3 weightedColorSum = vec3(0.0);
                    
                    for (int i = 0; i < 6; i++) {
                        if (i >= u_circleCount) { break; }
                        vec3 posRad = u_circlesPosRad[i];
                        vec2 cPos = vec2(posRad.r, posRad.g);
                        float radius = posRad.b;
                        float dist = length(st - cPos);
                        float sigma = radius * 0.5;
                        float val = exp(- (dist * dist) / (2.0 * sigma * sigma));
                        fieldSum += val;
                        weightedColorSum += u_circlesColor[i] * val;
                    }

                    vec3 finalCirclesColor = vec3(0.0);
                    if (fieldSum > 0.0) {
                        finalCirclesColor = weightedColorSum / fieldSum;
                    }

                    float intensity = pow(fieldSum, 1.4);
                    vec3 finalColor = mix(bgColor, finalCirclesColor, clamp(intensity, 0.0, 1.0));
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            function createShader(type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error("Shader compile error:", gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            const vertShader = createShader(gl.VERTEX_SHADER, vertexSrc);
            const fragShader = createShader(gl.FRAGMENT_SHADER, fragmentSrc);

            const program = gl.createProgram();
            gl.attachShader(program, vertShader);
            gl.attachShader(program, fragShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error("Program link error:", gl.getProgramInfoLog(program));
            }

            gl.useProgram(program);

            const quadBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
            const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            const a_position = gl.getAttribLocation(program, "a_position");
            gl.enableVertexAttribArray(a_position);
            gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);

            const u_resolution = gl.getUniformLocation(program, "u_resolution");
            const u_darkMode = gl.getUniformLocation(program, "u_darkMode");
            const u_circleCount = gl.getUniformLocation(program, "u_circleCount");
            const u_circlesColor = gl.getUniformLocation(program, "u_circlesColor");
            const u_circlesPosRad = gl.getUniformLocation(program, "u_circlesPosRad");
            const u_mouse = gl.getUniformLocation(program, "u_mouse");

            gl.uniform2f(u_resolution, width, height);

            function updateCircles() {
                for (let i = 0; i < circles.length; i++) {
                    const c = circles[i];
                    if (!c.interactive) {
                        c.x += c.vx;
                        c.y += c.vy;
                        if (c.x - c.radius > width) c.x = -c.radius;
                        if (c.x + c.radius < 0) c.x = width + c.radius;
                        if (c.y - c.radius > height) c.y = -c.radius;
                        if (c.y + c.radius < 0) c.y = height + c.radius;
                    } else {
                        c.x += (mouse.x - c.x) * 0.1;
                        c.y += (mouse.y - c.y) * 0.1;
                    }
                }
            }

            function render() {
                updateCircles();

                gl.viewport(0, 0, width, height);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.useProgram(program);

                gl.uniform1i(u_circleCount, circles.length);
                gl.uniform2f(u_resolution, width, height);
                gl.uniform2f(u_mouse, mouse.x, mouse.y);

                let colorsArr = [];
                let posRadArr = [];
                for (let i = 0; i < 6; i++) {
                    if (i < circles.length) {
                        const c = circles[i];
                        colorsArr.push(c.color[0], c.color[1], c.color[2]);
                        posRadArr.push(c.x, c.y, c.radius);
                    } else {
                        colorsArr.push(0, 0, 0);
                        posRadArr.push(0, 0, 0);
                    }
                }

                gl.uniform3fv(u_circlesColor, new Float32Array(colorsArr));
                gl.uniform3fv(u_circlesPosRad, new Float32Array(posRadArr));

                gl.drawArrays(gl.TRIANGLES, 0, 6);
                requestAnimationFrame(render);
            }

            render();
        });
    </script>
    <script src="../cursor-trail.js"></script>
    <script src="cursor-trail.js"></script>
</body>
</html>